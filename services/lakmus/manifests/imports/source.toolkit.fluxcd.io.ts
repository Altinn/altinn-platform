// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Bucket is the Schema for the buckets API.
 *
 * @schema Bucket
 */
export class Bucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "Bucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketProps = {}): any {
    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(props),
    };
  }

  /**
   * Defines a "Bucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketProps = {}) {
    super(scope, id, {
      ...Bucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the buckets API.
 *
 * @schema Bucket
 */
export interface BucketProps {
  /**
   * @schema Bucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec specifies the required configuration to produce an Artifact for
   * an object storage bucket.
   *
   * @schema Bucket#spec
   */
  readonly spec?: BucketSpec;

}

/**
 * Converts an object of type 'BucketProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketProps(obj: BucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BucketSpec specifies the required configuration to produce an Artifact for
 * an object storage bucket.
 *
 * @schema BucketSpec
 */
export interface BucketSpec {
  /**
   * BucketName is the name of the object storage bucket.
   *
   * @schema BucketSpec#bucketName
   */
  readonly bucketName: string;

  /**
   * CertSecretRef can be given the name of a Secret containing
   * either or both of
   *
   * - a PEM-encoded client certificate (`tls.crt`) and private
   * key (`tls.key`);
   * - a PEM-encoded CA certificate (`ca.crt`)
   *
   * and whichever are supplied, will be used for connecting to the
   * bucket. The client cert and key are useful if you are
   * authenticating with a certificate; the CA cert is useful if
   * you are using a self-signed server certificate. The Secret must
   * be of type `Opaque` or `kubernetes.io/tls`.
   *
   * This field is only supported for the `generic` provider.
   *
   * @schema BucketSpec#certSecretRef
   */
  readonly certSecretRef?: BucketSpecCertSecretRef;

  /**
   * Endpoint is the object storage address the BucketName is located at.
   *
   * @schema BucketSpec#endpoint
   */
  readonly endpoint: string;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format
   * (which is the same as .gitignore). If not provided, a default will be used,
   * consult the documentation for your version to find out what those are.
   *
   * @schema BucketSpec#ignore
   */
  readonly ignore?: string;

  /**
   * Insecure allows connecting to a non-TLS HTTP Endpoint.
   *
   * @schema BucketSpec#insecure
   */
  readonly insecure?: boolean;

  /**
   * Interval at which the Bucket Endpoint is checked for updates.
   * This interval is approximate and may be subject to jitter to ensure
   * efficient use of resources.
   *
   * @schema BucketSpec#interval
   */
  readonly interval: string;

  /**
   * Prefix to use for server-side filtering of files in the Bucket.
   *
   * @schema BucketSpec#prefix
   */
  readonly prefix?: string;

  /**
   * Provider of the object storage bucket.
   * Defaults to 'generic', which expects an S3 (API) compatible object
   * storage.
   *
   * @default generic', which expects an S3 (API) compatible object
   * @schema BucketSpec#provider
   */
  readonly provider?: BucketSpecProvider;

  /**
   * ProxySecretRef specifies the Secret containing the proxy configuration
   * to use while communicating with the Bucket server.
   *
   * @schema BucketSpec#proxySecretRef
   */
  readonly proxySecretRef?: BucketSpecProxySecretRef;

  /**
   * Region of the Endpoint where the BucketName is located in.
   *
   * @schema BucketSpec#region
   */
  readonly region?: string;

  /**
   * SecretRef specifies the Secret containing authentication credentials
   * for the Bucket.
   *
   * @schema BucketSpec#secretRef
   */
  readonly secretRef?: BucketSpecSecretRef;

  /**
   * STS specifies the required configuration to use a Security Token
   * Service for fetching temporary credentials to authenticate in a
   * Bucket provider.
   *
   * This field is only supported for the `aws` and `generic` providers.
   *
   * @schema BucketSpec#sts
   */
  readonly sts?: BucketSpecSts;

  /**
   * Suspend tells the controller to suspend the reconciliation of this
   * Bucket.
   *
   * @schema BucketSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for fetch operations, defaults to 60s.
   *
   * @schema BucketSpec#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'BucketSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpec(obj: BucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'certSecretRef': toJson_BucketSpecCertSecretRef(obj.certSecretRef),
    'endpoint': obj.endpoint,
    'ignore': obj.ignore,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'prefix': obj.prefix,
    'provider': obj.provider,
    'proxySecretRef': toJson_BucketSpecProxySecretRef(obj.proxySecretRef),
    'region': obj.region,
    'secretRef': toJson_BucketSpecSecretRef(obj.secretRef),
    'sts': toJson_BucketSpecSts(obj.sts),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef can be given the name of a Secret containing
 * either or both of
 *
 * - a PEM-encoded client certificate (`tls.crt`) and private
 * key (`tls.key`);
 * - a PEM-encoded CA certificate (`ca.crt`)
 *
 * and whichever are supplied, will be used for connecting to the
 * bucket. The client cert and key are useful if you are
 * authenticating with a certificate; the CA cert is useful if
 * you are using a self-signed server certificate. The Secret must
 * be of type `Opaque` or `kubernetes.io/tls`.
 *
 * This field is only supported for the `generic` provider.
 *
 * @schema BucketSpecCertSecretRef
 */
export interface BucketSpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketSpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecCertSecretRef(obj: BucketSpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider of the object storage bucket.
 * Defaults to 'generic', which expects an S3 (API) compatible object
 * storage.
 *
 * @default generic', which expects an S3 (API) compatible object
 * @schema BucketSpecProvider
 */
export enum BucketSpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** gcp */
  GCP = "gcp",
  /** azure */
  AZURE = "azure",
}

/**
 * ProxySecretRef specifies the Secret containing the proxy configuration
 * to use while communicating with the Bucket server.
 *
 * @schema BucketSpecProxySecretRef
 */
export interface BucketSpecProxySecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketSpecProxySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecProxySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecProxySecretRef(obj: BucketSpecProxySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef specifies the Secret containing authentication credentials
 * for the Bucket.
 *
 * @schema BucketSpecSecretRef
 */
export interface BucketSpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketSpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecSecretRef(obj: BucketSpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * STS specifies the required configuration to use a Security Token
 * Service for fetching temporary credentials to authenticate in a
 * Bucket provider.
 *
 * This field is only supported for the `aws` and `generic` providers.
 *
 * @schema BucketSpecSts
 */
export interface BucketSpecSts {
  /**
   * CertSecretRef can be given the name of a Secret containing
   * either or both of
   *
   * - a PEM-encoded client certificate (`tls.crt`) and private
   * key (`tls.key`);
   * - a PEM-encoded CA certificate (`ca.crt`)
   *
   * and whichever are supplied, will be used for connecting to the
   * STS endpoint. The client cert and key are useful if you are
   * authenticating with a certificate; the CA cert is useful if
   * you are using a self-signed server certificate. The Secret must
   * be of type `Opaque` or `kubernetes.io/tls`.
   *
   * This field is only supported for the `ldap` provider.
   *
   * @schema BucketSpecSts#certSecretRef
   */
  readonly certSecretRef?: BucketSpecStsCertSecretRef;

  /**
   * Endpoint is the HTTP/S endpoint of the Security Token Service from
   * where temporary credentials will be fetched.
   *
   * @schema BucketSpecSts#endpoint
   */
  readonly endpoint: string;

  /**
   * Provider of the Security Token Service.
   *
   * @schema BucketSpecSts#provider
   */
  readonly provider: BucketSpecStsProvider;

  /**
   * SecretRef specifies the Secret containing authentication credentials
   * for the STS endpoint. This Secret must contain the fields `username`
   * and `password` and is supported only for the `ldap` provider.
   *
   * @schema BucketSpecSts#secretRef
   */
  readonly secretRef?: BucketSpecStsSecretRef;

}

/**
 * Converts an object of type 'BucketSpecSts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecSts(obj: BucketSpecSts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_BucketSpecStsCertSecretRef(obj.certSecretRef),
    'endpoint': obj.endpoint,
    'provider': obj.provider,
    'secretRef': toJson_BucketSpecStsSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef can be given the name of a Secret containing
 * either or both of
 *
 * - a PEM-encoded client certificate (`tls.crt`) and private
 * key (`tls.key`);
 * - a PEM-encoded CA certificate (`ca.crt`)
 *
 * and whichever are supplied, will be used for connecting to the
 * STS endpoint. The client cert and key are useful if you are
 * authenticating with a certificate; the CA cert is useful if
 * you are using a self-signed server certificate. The Secret must
 * be of type `Opaque` or `kubernetes.io/tls`.
 *
 * This field is only supported for the `ldap` provider.
 *
 * @schema BucketSpecStsCertSecretRef
 */
export interface BucketSpecStsCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketSpecStsCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecStsCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecStsCertSecretRef(obj: BucketSpecStsCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider of the Security Token Service.
 *
 * @schema BucketSpecStsProvider
 */
export enum BucketSpecStsProvider {
  /** aws */
  AWS = "aws",
  /** ldap */
  LDAP = "ldap",
}

/**
 * SecretRef specifies the Secret containing authentication credentials
 * for the STS endpoint. This Secret must contain the fields `username`
 * and `password` and is supported only for the `ldap` provider.
 *
 * @schema BucketSpecStsSecretRef
 */
export interface BucketSpecStsSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketSpecStsSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecStsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecStsSecretRef(obj: BucketSpecStsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * Bucket is the Schema for the buckets API
 *
 * @schema BucketV1Beta1
 */
export class BucketV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "BucketV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketV1Beta1Props = {}): any {
    return {
      ...BucketV1Beta1.GVK,
      ...toJson_BucketV1Beta1Props(props),
    };
  }

  /**
   * Defines a "BucketV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketV1Beta1Props = {}) {
    super(scope, id, {
      ...BucketV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketV1Beta1.GVK,
      ...toJson_BucketV1Beta1Props(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the buckets API
 *
 * @schema BucketV1Beta1
 */
export interface BucketV1Beta1Props {
  /**
   * @schema BucketV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec defines the desired state of an S3 compatible bucket
   *
   * @schema BucketV1Beta1#spec
   */
  readonly spec?: BucketV1Beta1Spec;

}

/**
 * Converts an object of type 'BucketV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta1Props(obj: BucketV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BucketSpec defines the desired state of an S3 compatible bucket
 *
 * @schema BucketV1Beta1Spec
 */
export interface BucketV1Beta1Spec {
  /**
   * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
   *
   * @schema BucketV1Beta1Spec#accessFrom
   */
  readonly accessFrom?: BucketV1Beta1SpecAccessFrom;

  /**
   * The bucket name.
   *
   * @schema BucketV1Beta1Spec#bucketName
   */
  readonly bucketName: string;

  /**
   * The bucket endpoint address.
   *
   * @schema BucketV1Beta1Spec#endpoint
   */
  readonly endpoint: string;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format
   * (which is the same as .gitignore). If not provided, a default will be used,
   * consult the documentation for your version to find out what those are.
   *
   * @schema BucketV1Beta1Spec#ignore
   */
  readonly ignore?: string;

  /**
   * Insecure allows connecting to a non-TLS S3 HTTP endpoint.
   *
   * @schema BucketV1Beta1Spec#insecure
   */
  readonly insecure?: boolean;

  /**
   * The interval at which to check for bucket updates.
   *
   * @schema BucketV1Beta1Spec#interval
   */
  readonly interval: string;

  /**
   * The S3 compatible storage provider name, default ('generic').
   *
   * @schema BucketV1Beta1Spec#provider
   */
  readonly provider?: BucketV1Beta1SpecProvider;

  /**
   * The bucket region.
   *
   * @schema BucketV1Beta1Spec#region
   */
  readonly region?: string;

  /**
   * The name of the secret containing authentication credentials
   * for the Bucket.
   *
   * @schema BucketV1Beta1Spec#secretRef
   */
  readonly secretRef?: BucketV1Beta1SpecSecretRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema BucketV1Beta1Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout for download operations, defaults to 60s.
   *
   * @schema BucketV1Beta1Spec#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'BucketV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta1Spec(obj: BucketV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_BucketV1Beta1SpecAccessFrom(obj.accessFrom),
    'bucketName': obj.bucketName,
    'endpoint': obj.endpoint,
    'ignore': obj.ignore,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'provider': obj.provider,
    'region': obj.region,
    'secretRef': toJson_BucketV1Beta1SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
 *
 * @schema BucketV1Beta1SpecAccessFrom
 */
export interface BucketV1Beta1SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema BucketV1Beta1SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: BucketV1Beta1SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'BucketV1Beta1SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta1SpecAccessFrom(obj: BucketV1Beta1SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_BucketV1Beta1SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The S3 compatible storage provider name, default ('generic').
 *
 * @schema BucketV1Beta1SpecProvider
 */
export enum BucketV1Beta1SpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** gcp */
  GCP = "gcp",
}

/**
 * The name of the secret containing authentication credentials
 * for the Bucket.
 *
 * @schema BucketV1Beta1SpecSecretRef
 */
export interface BucketV1Beta1SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketV1Beta1SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketV1Beta1SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta1SpecSecretRef(obj: BucketV1Beta1SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema BucketV1Beta1SpecAccessFromNamespaceSelectors
 */
export interface BucketV1Beta1SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BucketV1Beta1SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BucketV1Beta1SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta1SpecAccessFromNamespaceSelectors(obj: BucketV1Beta1SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * Bucket is the Schema for the buckets API.
 *
 * @schema BucketV1Beta2
 */
export class BucketV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta2',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "BucketV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketV1Beta2Props = {}): any {
    return {
      ...BucketV1Beta2.GVK,
      ...toJson_BucketV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BucketV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketV1Beta2Props = {}) {
    super(scope, id, {
      ...BucketV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketV1Beta2.GVK,
      ...toJson_BucketV1Beta2Props(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the buckets API.
 *
 * @schema BucketV1Beta2
 */
export interface BucketV1Beta2Props {
  /**
   * @schema BucketV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec specifies the required configuration to produce an Artifact for
   * an object storage bucket.
   *
   * @schema BucketV1Beta2#spec
   */
  readonly spec?: BucketV1Beta2Spec;

}

/**
 * Converts an object of type 'BucketV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2Props(obj: BucketV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BucketSpec specifies the required configuration to produce an Artifact for
 * an object storage bucket.
 *
 * @schema BucketV1Beta2Spec
 */
export interface BucketV1Beta2Spec {
  /**
   * AccessFrom specifies an Access Control List for allowing cross-namespace
   * references to this object.
   * NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
   *
   * @schema BucketV1Beta2Spec#accessFrom
   */
  readonly accessFrom?: BucketV1Beta2SpecAccessFrom;

  /**
   * BucketName is the name of the object storage bucket.
   *
   * @schema BucketV1Beta2Spec#bucketName
   */
  readonly bucketName: string;

  /**
   * CertSecretRef can be given the name of a Secret containing
   * either or both of
   *
   * - a PEM-encoded client certificate (`tls.crt`) and private
   * key (`tls.key`);
   * - a PEM-encoded CA certificate (`ca.crt`)
   *
   * and whichever are supplied, will be used for connecting to the
   * bucket. The client cert and key are useful if you are
   * authenticating with a certificate; the CA cert is useful if
   * you are using a self-signed server certificate. The Secret must
   * be of type `Opaque` or `kubernetes.io/tls`.
   *
   * This field is only supported for the `generic` provider.
   *
   * @schema BucketV1Beta2Spec#certSecretRef
   */
  readonly certSecretRef?: BucketV1Beta2SpecCertSecretRef;

  /**
   * Endpoint is the object storage address the BucketName is located at.
   *
   * @schema BucketV1Beta2Spec#endpoint
   */
  readonly endpoint: string;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format
   * (which is the same as .gitignore). If not provided, a default will be used,
   * consult the documentation for your version to find out what those are.
   *
   * @schema BucketV1Beta2Spec#ignore
   */
  readonly ignore?: string;

  /**
   * Insecure allows connecting to a non-TLS HTTP Endpoint.
   *
   * @schema BucketV1Beta2Spec#insecure
   */
  readonly insecure?: boolean;

  /**
   * Interval at which the Bucket Endpoint is checked for updates.
   * This interval is approximate and may be subject to jitter to ensure
   * efficient use of resources.
   *
   * @schema BucketV1Beta2Spec#interval
   */
  readonly interval: string;

  /**
   * Prefix to use for server-side filtering of files in the Bucket.
   *
   * @schema BucketV1Beta2Spec#prefix
   */
  readonly prefix?: string;

  /**
   * Provider of the object storage bucket.
   * Defaults to 'generic', which expects an S3 (API) compatible object
   * storage.
   *
   * @default generic', which expects an S3 (API) compatible object
   * @schema BucketV1Beta2Spec#provider
   */
  readonly provider?: BucketV1Beta2SpecProvider;

  /**
   * ProxySecretRef specifies the Secret containing the proxy configuration
   * to use while communicating with the Bucket server.
   *
   * @schema BucketV1Beta2Spec#proxySecretRef
   */
  readonly proxySecretRef?: BucketV1Beta2SpecProxySecretRef;

  /**
   * Region of the Endpoint where the BucketName is located in.
   *
   * @schema BucketV1Beta2Spec#region
   */
  readonly region?: string;

  /**
   * SecretRef specifies the Secret containing authentication credentials
   * for the Bucket.
   *
   * @schema BucketV1Beta2Spec#secretRef
   */
  readonly secretRef?: BucketV1Beta2SpecSecretRef;

  /**
   * STS specifies the required configuration to use a Security Token
   * Service for fetching temporary credentials to authenticate in a
   * Bucket provider.
   *
   * This field is only supported for the `aws` and `generic` providers.
   *
   * @schema BucketV1Beta2Spec#sts
   */
  readonly sts?: BucketV1Beta2SpecSts;

  /**
   * Suspend tells the controller to suspend the reconciliation of this
   * Bucket.
   *
   * @schema BucketV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for fetch operations, defaults to 60s.
   *
   * @schema BucketV1Beta2Spec#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'BucketV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2Spec(obj: BucketV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_BucketV1Beta2SpecAccessFrom(obj.accessFrom),
    'bucketName': obj.bucketName,
    'certSecretRef': toJson_BucketV1Beta2SpecCertSecretRef(obj.certSecretRef),
    'endpoint': obj.endpoint,
    'ignore': obj.ignore,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'prefix': obj.prefix,
    'provider': obj.provider,
    'proxySecretRef': toJson_BucketV1Beta2SpecProxySecretRef(obj.proxySecretRef),
    'region': obj.region,
    'secretRef': toJson_BucketV1Beta2SpecSecretRef(obj.secretRef),
    'sts': toJson_BucketV1Beta2SpecSts(obj.sts),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom specifies an Access Control List for allowing cross-namespace
 * references to this object.
 * NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
 *
 * @schema BucketV1Beta2SpecAccessFrom
 */
export interface BucketV1Beta2SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema BucketV1Beta2SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: BucketV1Beta2SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'BucketV1Beta2SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecAccessFrom(obj: BucketV1Beta2SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_BucketV1Beta2SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef can be given the name of a Secret containing
 * either or both of
 *
 * - a PEM-encoded client certificate (`tls.crt`) and private
 * key (`tls.key`);
 * - a PEM-encoded CA certificate (`ca.crt`)
 *
 * and whichever are supplied, will be used for connecting to the
 * bucket. The client cert and key are useful if you are
 * authenticating with a certificate; the CA cert is useful if
 * you are using a self-signed server certificate. The Secret must
 * be of type `Opaque` or `kubernetes.io/tls`.
 *
 * This field is only supported for the `generic` provider.
 *
 * @schema BucketV1Beta2SpecCertSecretRef
 */
export interface BucketV1Beta2SpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketV1Beta2SpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketV1Beta2SpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecCertSecretRef(obj: BucketV1Beta2SpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider of the object storage bucket.
 * Defaults to 'generic', which expects an S3 (API) compatible object
 * storage.
 *
 * @default generic', which expects an S3 (API) compatible object
 * @schema BucketV1Beta2SpecProvider
 */
export enum BucketV1Beta2SpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** gcp */
  GCP = "gcp",
  /** azure */
  AZURE = "azure",
}

/**
 * ProxySecretRef specifies the Secret containing the proxy configuration
 * to use while communicating with the Bucket server.
 *
 * @schema BucketV1Beta2SpecProxySecretRef
 */
export interface BucketV1Beta2SpecProxySecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketV1Beta2SpecProxySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketV1Beta2SpecProxySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecProxySecretRef(obj: BucketV1Beta2SpecProxySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef specifies the Secret containing authentication credentials
 * for the Bucket.
 *
 * @schema BucketV1Beta2SpecSecretRef
 */
export interface BucketV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketV1Beta2SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecSecretRef(obj: BucketV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * STS specifies the required configuration to use a Security Token
 * Service for fetching temporary credentials to authenticate in a
 * Bucket provider.
 *
 * This field is only supported for the `aws` and `generic` providers.
 *
 * @schema BucketV1Beta2SpecSts
 */
export interface BucketV1Beta2SpecSts {
  /**
   * CertSecretRef can be given the name of a Secret containing
   * either or both of
   *
   * - a PEM-encoded client certificate (`tls.crt`) and private
   * key (`tls.key`);
   * - a PEM-encoded CA certificate (`ca.crt`)
   *
   * and whichever are supplied, will be used for connecting to the
   * STS endpoint. The client cert and key are useful if you are
   * authenticating with a certificate; the CA cert is useful if
   * you are using a self-signed server certificate. The Secret must
   * be of type `Opaque` or `kubernetes.io/tls`.
   *
   * This field is only supported for the `ldap` provider.
   *
   * @schema BucketV1Beta2SpecSts#certSecretRef
   */
  readonly certSecretRef?: BucketV1Beta2SpecStsCertSecretRef;

  /**
   * Endpoint is the HTTP/S endpoint of the Security Token Service from
   * where temporary credentials will be fetched.
   *
   * @schema BucketV1Beta2SpecSts#endpoint
   */
  readonly endpoint: string;

  /**
   * Provider of the Security Token Service.
   *
   * @schema BucketV1Beta2SpecSts#provider
   */
  readonly provider: BucketV1Beta2SpecStsProvider;

  /**
   * SecretRef specifies the Secret containing authentication credentials
   * for the STS endpoint. This Secret must contain the fields `username`
   * and `password` and is supported only for the `ldap` provider.
   *
   * @schema BucketV1Beta2SpecSts#secretRef
   */
  readonly secretRef?: BucketV1Beta2SpecStsSecretRef;

}

/**
 * Converts an object of type 'BucketV1Beta2SpecSts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecSts(obj: BucketV1Beta2SpecSts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_BucketV1Beta2SpecStsCertSecretRef(obj.certSecretRef),
    'endpoint': obj.endpoint,
    'provider': obj.provider,
    'secretRef': toJson_BucketV1Beta2SpecStsSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema BucketV1Beta2SpecAccessFromNamespaceSelectors
 */
export interface BucketV1Beta2SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BucketV1Beta2SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BucketV1Beta2SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecAccessFromNamespaceSelectors(obj: BucketV1Beta2SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef can be given the name of a Secret containing
 * either or both of
 *
 * - a PEM-encoded client certificate (`tls.crt`) and private
 * key (`tls.key`);
 * - a PEM-encoded CA certificate (`ca.crt`)
 *
 * and whichever are supplied, will be used for connecting to the
 * STS endpoint. The client cert and key are useful if you are
 * authenticating with a certificate; the CA cert is useful if
 * you are using a self-signed server certificate. The Secret must
 * be of type `Opaque` or `kubernetes.io/tls`.
 *
 * This field is only supported for the `ldap` provider.
 *
 * @schema BucketV1Beta2SpecStsCertSecretRef
 */
export interface BucketV1Beta2SpecStsCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketV1Beta2SpecStsCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketV1Beta2SpecStsCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecStsCertSecretRef(obj: BucketV1Beta2SpecStsCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider of the Security Token Service.
 *
 * @schema BucketV1Beta2SpecStsProvider
 */
export enum BucketV1Beta2SpecStsProvider {
  /** aws */
  AWS = "aws",
  /** ldap */
  LDAP = "ldap",
}

/**
 * SecretRef specifies the Secret containing authentication credentials
 * for the STS endpoint. This Secret must contain the fields `username`
 * and `password` and is supported only for the `ldap` provider.
 *
 * @schema BucketV1Beta2SpecStsSecretRef
 */
export interface BucketV1Beta2SpecStsSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketV1Beta2SpecStsSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketV1Beta2SpecStsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecStsSecretRef(obj: BucketV1Beta2SpecStsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * GitRepository is the Schema for the gitrepositories API.
 *
 * @schema GitRepository
 */
export class GitRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GitRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1',
    kind: 'GitRepository',
  }

  /**
   * Renders a Kubernetes manifest for "GitRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GitRepositoryProps = {}): any {
    return {
      ...GitRepository.GVK,
      ...toJson_GitRepositoryProps(props),
    };
  }

  /**
   * Defines a "GitRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GitRepositoryProps = {}) {
    super(scope, id, {
      ...GitRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GitRepository.GVK,
      ...toJson_GitRepositoryProps(resolved),
    };
  }
}

/**
 * GitRepository is the Schema for the gitrepositories API.
 *
 * @schema GitRepository
 */
export interface GitRepositoryProps {
  /**
   * @schema GitRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GitRepositorySpec specifies the required configuration to produce an
   * Artifact for a Git repository.
   *
   * @schema GitRepository#spec
   */
  readonly spec?: GitRepositorySpec;

}

/**
 * Converts an object of type 'GitRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryProps(obj: GitRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GitRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitRepositorySpec specifies the required configuration to produce an
 * Artifact for a Git repository.
 *
 * @schema GitRepositorySpec
 */
export interface GitRepositorySpec {
  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format
   * (which is the same as .gitignore). If not provided, a default will be used,
   * consult the documentation for your version to find out what those are.
   *
   * @schema GitRepositorySpec#ignore
   */
  readonly ignore?: string;

  /**
   * Include specifies a list of GitRepository resources which Artifacts
   * should be included in the Artifact produced for this GitRepository.
   *
   * @schema GitRepositorySpec#include
   */
  readonly include?: GitRepositorySpecInclude[];

  /**
   * Interval at which the GitRepository URL is checked for updates.
   * This interval is approximate and may be subject to jitter to ensure
   * efficient use of resources.
   *
   * @schema GitRepositorySpec#interval
   */
  readonly interval: string;

  /**
   * Provider used for authentication, can be 'azure', 'github', 'generic'.
   * When not specified, defaults to 'generic'.
   *
   * @schema GitRepositorySpec#provider
   */
  readonly provider?: GitRepositorySpecProvider;

  /**
   * ProxySecretRef specifies the Secret containing the proxy configuration
   * to use while communicating with the Git server.
   *
   * @schema GitRepositorySpec#proxySecretRef
   */
  readonly proxySecretRef?: GitRepositorySpecProxySecretRef;

  /**
   * RecurseSubmodules enables the initialization of all submodules within
   * the GitRepository as cloned from the URL, using their default settings.
   *
   * @schema GitRepositorySpec#recurseSubmodules
   */
  readonly recurseSubmodules?: boolean;

  /**
   * Reference specifies the Git reference to resolve and monitor for
   * changes, defaults to the 'master' branch.
   *
   * @schema GitRepositorySpec#ref
   */
  readonly ref?: GitRepositorySpecRef;

  /**
   * SecretRef specifies the Secret containing authentication credentials for
   * the GitRepository.
   * For HTTPS repositories the Secret must contain 'username' and 'password'
   * fields for basic auth or 'bearerToken' field for token auth.
   * For SSH repositories the Secret must contain 'identity'
   * and 'known_hosts' fields.
   *
   * @schema GitRepositorySpec#secretRef
   */
  readonly secretRef?: GitRepositorySpecSecretRef;

  /**
   * SparseCheckout specifies a list of directories to checkout when cloning
   * the repository. If specified, only these directories are included in the
   * Artifact produced for this GitRepository.
   *
   * @schema GitRepositorySpec#sparseCheckout
   */
  readonly sparseCheckout?: string[];

  /**
   * Suspend tells the controller to suspend the reconciliation of this
   * GitRepository.
   *
   * @schema GitRepositorySpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for Git operations like cloning, defaults to 60s.
   *
   * @schema GitRepositorySpec#timeout
   */
  readonly timeout?: string;

  /**
   * URL specifies the Git repository URL, it can be an HTTP/S or SSH address.
   *
   * @schema GitRepositorySpec#url
   */
  readonly url: string;

  /**
   * Verification specifies the configuration to verify the Git commit
   * signature(s).
   *
   * @schema GitRepositorySpec#verify
   */
  readonly verify?: GitRepositorySpecVerify;

}

/**
 * Converts an object of type 'GitRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpec(obj: GitRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignore': obj.ignore,
    'include': obj.include?.map(y => toJson_GitRepositorySpecInclude(y)),
    'interval': obj.interval,
    'provider': obj.provider,
    'proxySecretRef': toJson_GitRepositorySpecProxySecretRef(obj.proxySecretRef),
    'recurseSubmodules': obj.recurseSubmodules,
    'ref': toJson_GitRepositorySpecRef(obj.ref),
    'secretRef': toJson_GitRepositorySpecSecretRef(obj.secretRef),
    'sparseCheckout': obj.sparseCheckout?.map(y => y),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
    'verify': toJson_GitRepositorySpecVerify(obj.verify),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitRepositoryInclude specifies a local reference to a GitRepository which
 * Artifact (sub-)contents must be included, and where they should be placed.
 *
 * @schema GitRepositorySpecInclude
 */
export interface GitRepositorySpecInclude {
  /**
   * FromPath specifies the path to copy contents from, defaults to the root
   * of the Artifact.
   *
   * @schema GitRepositorySpecInclude#fromPath
   */
  readonly fromPath?: string;

  /**
   * GitRepositoryRef specifies the GitRepository which Artifact contents
   * must be included.
   *
   * @schema GitRepositorySpecInclude#repository
   */
  readonly repository: GitRepositorySpecIncludeRepository;

  /**
   * ToPath specifies the path to copy contents to, defaults to the name of
   * the GitRepositoryRef.
   *
   * @schema GitRepositorySpecInclude#toPath
   */
  readonly toPath?: string;

}

/**
 * Converts an object of type 'GitRepositorySpecInclude' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecInclude(obj: GitRepositorySpecInclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPath': obj.fromPath,
    'repository': toJson_GitRepositorySpecIncludeRepository(obj.repository),
    'toPath': obj.toPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider used for authentication, can be 'azure', 'github', 'generic'.
 * When not specified, defaults to 'generic'.
 *
 * @schema GitRepositorySpecProvider
 */
export enum GitRepositorySpecProvider {
  /** generic */
  GENERIC = "generic",
  /** azure */
  AZURE = "azure",
  /** github */
  GITHUB = "github",
}

/**
 * ProxySecretRef specifies the Secret containing the proxy configuration
 * to use while communicating with the Git server.
 *
 * @schema GitRepositorySpecProxySecretRef
 */
export interface GitRepositorySpecProxySecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositorySpecProxySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecProxySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecProxySecretRef(obj: GitRepositorySpecProxySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference specifies the Git reference to resolve and monitor for
 * changes, defaults to the 'master' branch.
 *
 * @schema GitRepositorySpecRef
 */
export interface GitRepositorySpecRef {
  /**
   * Branch to check out, defaults to 'master' if no other field is defined.
   *
   * @schema GitRepositorySpecRef#branch
   */
  readonly branch?: string;

  /**
   * Commit SHA to check out, takes precedence over all reference fields.
   *
   * This can be combined with Branch to shallow clone the branch, in which
   * the commit is expected to exist.
   *
   * @schema GitRepositorySpecRef#commit
   */
  readonly commit?: string;

  /**
   * Name of the reference to check out; takes precedence over Branch, Tag and SemVer.
   *
   * It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description
   * Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
   *
   * @schema GitRepositorySpecRef#name
   */
  readonly name?: string;

  /**
   * SemVer tag expression to check out, takes precedence over Tag.
   *
   * @schema GitRepositorySpecRef#semver
   */
  readonly semver?: string;

  /**
   * Tag to check out, takes precedence over Branch.
   *
   * @schema GitRepositorySpecRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'GitRepositorySpecRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecRef(obj: GitRepositorySpecRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commit': obj.commit,
    'name': obj.name,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef specifies the Secret containing authentication credentials for
 * the GitRepository.
 * For HTTPS repositories the Secret must contain 'username' and 'password'
 * fields for basic auth or 'bearerToken' field for token auth.
 * For SSH repositories the Secret must contain 'identity'
 * and 'known_hosts' fields.
 *
 * @schema GitRepositorySpecSecretRef
 */
export interface GitRepositorySpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositorySpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecSecretRef(obj: GitRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Verification specifies the configuration to verify the Git commit
 * signature(s).
 *
 * @schema GitRepositorySpecVerify
 */
export interface GitRepositorySpecVerify {
  /**
   * Mode specifies which Git object(s) should be verified.
   *
   * The variants "head" and "HEAD" both imply the same thing, i.e. verify
   * the commit that the HEAD of the Git repository points to. The variant
   * "head" solely exists to ensure backwards compatibility.
   *
   * @schema GitRepositorySpecVerify#mode
   */
  readonly mode?: GitRepositorySpecVerifyMode;

  /**
   * SecretRef specifies the Secret containing the public keys of trusted Git
   * authors.
   *
   * @schema GitRepositorySpecVerify#secretRef
   */
  readonly secretRef: GitRepositorySpecVerifySecretRef;

}

/**
 * Converts an object of type 'GitRepositorySpecVerify' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecVerify(obj: GitRepositorySpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'secretRef': toJson_GitRepositorySpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitRepositoryRef specifies the GitRepository which Artifact contents
 * must be included.
 *
 * @schema GitRepositorySpecIncludeRepository
 */
export interface GitRepositorySpecIncludeRepository {
  /**
   * Name of the referent.
   *
   * @schema GitRepositorySpecIncludeRepository#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecIncludeRepository' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecIncludeRepository(obj: GitRepositorySpecIncludeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode specifies which Git object(s) should be verified.
 *
 * The variants "head" and "HEAD" both imply the same thing, i.e. verify
 * the commit that the HEAD of the Git repository points to. The variant
 * "head" solely exists to ensure backwards compatibility.
 *
 * @schema GitRepositorySpecVerifyMode
 */
export enum GitRepositorySpecVerifyMode {
  /** head */
  HEAD = "head",
  /** Tag */
  TAG = "Tag",
  /** TagAndHEAD */
  TAG_AND_HEAD = "TagAndHEAD",
}

/**
 * SecretRef specifies the Secret containing the public keys of trusted Git
 * authors.
 *
 * @schema GitRepositorySpecVerifySecretRef
 */
export interface GitRepositorySpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositorySpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecVerifySecretRef(obj: GitRepositorySpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * GitRepository is the Schema for the gitrepositories API
 *
 * @schema GitRepositoryV1Beta1
 */
export class GitRepositoryV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GitRepositoryV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'GitRepository',
  }

  /**
   * Renders a Kubernetes manifest for "GitRepositoryV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GitRepositoryV1Beta1Props = {}): any {
    return {
      ...GitRepositoryV1Beta1.GVK,
      ...toJson_GitRepositoryV1Beta1Props(props),
    };
  }

  /**
   * Defines a "GitRepositoryV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GitRepositoryV1Beta1Props = {}) {
    super(scope, id, {
      ...GitRepositoryV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GitRepositoryV1Beta1.GVK,
      ...toJson_GitRepositoryV1Beta1Props(resolved),
    };
  }
}

/**
 * GitRepository is the Schema for the gitrepositories API
 *
 * @schema GitRepositoryV1Beta1
 */
export interface GitRepositoryV1Beta1Props {
  /**
   * @schema GitRepositoryV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GitRepositorySpec defines the desired state of a Git repository.
   *
   * @schema GitRepositoryV1Beta1#spec
   */
  readonly spec?: GitRepositoryV1Beta1Spec;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta1Props(obj: GitRepositoryV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GitRepositoryV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitRepositorySpec defines the desired state of a Git repository.
 *
 * @schema GitRepositoryV1Beta1Spec
 */
export interface GitRepositoryV1Beta1Spec {
  /**
   * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
   *
   * @schema GitRepositoryV1Beta1Spec#accessFrom
   */
  readonly accessFrom?: GitRepositoryV1Beta1SpecAccessFrom;

  /**
   * Determines which git client library to use.
   * Defaults to go-git, valid values are ('go-git', 'libgit2').
   *
   * @default go-git, valid values are ('go-git', 'libgit2').
   * @schema GitRepositoryV1Beta1Spec#gitImplementation
   */
  readonly gitImplementation?: GitRepositoryV1Beta1SpecGitImplementation;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format
   * (which is the same as .gitignore). If not provided, a default will be used,
   * consult the documentation for your version to find out what those are.
   *
   * @schema GitRepositoryV1Beta1Spec#ignore
   */
  readonly ignore?: string;

  /**
   * Extra git repositories to map into the repository
   *
   * @schema GitRepositoryV1Beta1Spec#include
   */
  readonly include?: GitRepositoryV1Beta1SpecInclude[];

  /**
   * The interval at which to check for repository updates.
   *
   * @schema GitRepositoryV1Beta1Spec#interval
   */
  readonly interval: string;

  /**
   * When enabled, after the clone is created, initializes all submodules within,
   * using their default settings.
   * This option is available only when using the 'go-git' GitImplementation.
   *
   * @schema GitRepositoryV1Beta1Spec#recurseSubmodules
   */
  readonly recurseSubmodules?: boolean;

  /**
   * The Git reference to checkout and monitor for changes, defaults to
   * master branch.
   *
   * @schema GitRepositoryV1Beta1Spec#ref
   */
  readonly ref?: GitRepositoryV1Beta1SpecRef;

  /**
   * The secret name containing the Git credentials.
   * For HTTPS repositories the secret must contain username and password
   * fields.
   * For SSH repositories the secret must contain identity and known_hosts
   * fields.
   *
   * @schema GitRepositoryV1Beta1Spec#secretRef
   */
  readonly secretRef?: GitRepositoryV1Beta1SpecSecretRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema GitRepositoryV1Beta1Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout for remote Git operations like cloning, defaults to 60s.
   *
   * @schema GitRepositoryV1Beta1Spec#timeout
   */
  readonly timeout?: string;

  /**
   * The repository URL, can be a HTTP/S or SSH address.
   *
   * @schema GitRepositoryV1Beta1Spec#url
   */
  readonly url: string;

  /**
   * Verify OpenPGP signature for the Git commit HEAD points to.
   *
   * @schema GitRepositoryV1Beta1Spec#verify
   */
  readonly verify?: GitRepositoryV1Beta1SpecVerify;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta1Spec(obj: GitRepositoryV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_GitRepositoryV1Beta1SpecAccessFrom(obj.accessFrom),
    'gitImplementation': obj.gitImplementation,
    'ignore': obj.ignore,
    'include': obj.include?.map(y => toJson_GitRepositoryV1Beta1SpecInclude(y)),
    'interval': obj.interval,
    'recurseSubmodules': obj.recurseSubmodules,
    'ref': toJson_GitRepositoryV1Beta1SpecRef(obj.ref),
    'secretRef': toJson_GitRepositoryV1Beta1SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
    'verify': toJson_GitRepositoryV1Beta1SpecVerify(obj.verify),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
 *
 * @schema GitRepositoryV1Beta1SpecAccessFrom
 */
export interface GitRepositoryV1Beta1SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema GitRepositoryV1Beta1SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta1SpecAccessFrom(obj: GitRepositoryV1Beta1SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Determines which git client library to use.
 * Defaults to go-git, valid values are ('go-git', 'libgit2').
 *
 * @default go-git, valid values are ('go-git', 'libgit2').
 * @schema GitRepositoryV1Beta1SpecGitImplementation
 */
export enum GitRepositoryV1Beta1SpecGitImplementation {
  /** go-git */
  GO_HYPHEN_GIT = "go-git",
  /** libgit2 */
  LIBGIT2 = "libgit2",
}

/**
 * GitRepositoryInclude defines a source with a from and to path.
 *
 * @schema GitRepositoryV1Beta1SpecInclude
 */
export interface GitRepositoryV1Beta1SpecInclude {
  /**
   * The path to copy contents from, defaults to the root directory.
   *
   * @schema GitRepositoryV1Beta1SpecInclude#fromPath
   */
  readonly fromPath?: string;

  /**
   * Reference to a GitRepository to include.
   *
   * @schema GitRepositoryV1Beta1SpecInclude#repository
   */
  readonly repository: GitRepositoryV1Beta1SpecIncludeRepository;

  /**
   * The path to copy contents to, defaults to the name of the source ref.
   *
   * @schema GitRepositoryV1Beta1SpecInclude#toPath
   */
  readonly toPath?: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecInclude' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta1SpecInclude(obj: GitRepositoryV1Beta1SpecInclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPath': obj.fromPath,
    'repository': toJson_GitRepositoryV1Beta1SpecIncludeRepository(obj.repository),
    'toPath': obj.toPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Git reference to checkout and monitor for changes, defaults to
 * master branch.
 *
 * @schema GitRepositoryV1Beta1SpecRef
 */
export interface GitRepositoryV1Beta1SpecRef {
  /**
   * The Git branch to checkout, defaults to master.
   *
   * @schema GitRepositoryV1Beta1SpecRef#branch
   */
  readonly branch?: string;

  /**
   * The Git commit SHA to checkout, if specified Tag filters will be ignored.
   *
   * @schema GitRepositoryV1Beta1SpecRef#commit
   */
  readonly commit?: string;

  /**
   * The Git tag semver expression, takes precedence over Tag.
   *
   * @schema GitRepositoryV1Beta1SpecRef#semver
   */
  readonly semver?: string;

  /**
   * The Git tag to checkout, takes precedence over Branch.
   *
   * @schema GitRepositoryV1Beta1SpecRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta1SpecRef(obj: GitRepositoryV1Beta1SpecRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commit': obj.commit,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret name containing the Git credentials.
 * For HTTPS repositories the secret must contain username and password
 * fields.
 * For SSH repositories the secret must contain identity and known_hosts
 * fields.
 *
 * @schema GitRepositoryV1Beta1SpecSecretRef
 */
export interface GitRepositoryV1Beta1SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta1SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta1SpecSecretRef(obj: GitRepositoryV1Beta1SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Verify OpenPGP signature for the Git commit HEAD points to.
 *
 * @schema GitRepositoryV1Beta1SpecVerify
 */
export interface GitRepositoryV1Beta1SpecVerify {
  /**
   * Mode describes what git object should be verified, currently ('head').
   *
   * @schema GitRepositoryV1Beta1SpecVerify#mode
   */
  readonly mode: GitRepositoryV1Beta1SpecVerifyMode;

  /**
   * The secret name containing the public keys of all trusted Git authors.
   *
   * @schema GitRepositoryV1Beta1SpecVerify#secretRef
   */
  readonly secretRef?: GitRepositoryV1Beta1SpecVerifySecretRef;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecVerify' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta1SpecVerify(obj: GitRepositoryV1Beta1SpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'secretRef': toJson_GitRepositoryV1Beta1SpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors
 */
export interface GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors(obj: GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a GitRepository to include.
 *
 * @schema GitRepositoryV1Beta1SpecIncludeRepository
 */
export interface GitRepositoryV1Beta1SpecIncludeRepository {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta1SpecIncludeRepository#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecIncludeRepository' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta1SpecIncludeRepository(obj: GitRepositoryV1Beta1SpecIncludeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode describes what git object should be verified, currently ('head').
 *
 * @schema GitRepositoryV1Beta1SpecVerifyMode
 */
export enum GitRepositoryV1Beta1SpecVerifyMode {
  /** head */
  HEAD = "head",
}

/**
 * The secret name containing the public keys of all trusted Git authors.
 *
 * @schema GitRepositoryV1Beta1SpecVerifySecretRef
 */
export interface GitRepositoryV1Beta1SpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta1SpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta1SpecVerifySecretRef(obj: GitRepositoryV1Beta1SpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * GitRepository is the Schema for the gitrepositories API.
 *
 * @schema GitRepositoryV1Beta2
 */
export class GitRepositoryV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GitRepositoryV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta2',
    kind: 'GitRepository',
  }

  /**
   * Renders a Kubernetes manifest for "GitRepositoryV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GitRepositoryV1Beta2Props = {}): any {
    return {
      ...GitRepositoryV1Beta2.GVK,
      ...toJson_GitRepositoryV1Beta2Props(props),
    };
  }

  /**
   * Defines a "GitRepositoryV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GitRepositoryV1Beta2Props = {}) {
    super(scope, id, {
      ...GitRepositoryV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GitRepositoryV1Beta2.GVK,
      ...toJson_GitRepositoryV1Beta2Props(resolved),
    };
  }
}

/**
 * GitRepository is the Schema for the gitrepositories API.
 *
 * @schema GitRepositoryV1Beta2
 */
export interface GitRepositoryV1Beta2Props {
  /**
   * @schema GitRepositoryV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GitRepositorySpec specifies the required configuration to produce an
   * Artifact for a Git repository.
   *
   * @schema GitRepositoryV1Beta2#spec
   */
  readonly spec?: GitRepositoryV1Beta2Spec;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta2Props(obj: GitRepositoryV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GitRepositoryV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitRepositorySpec specifies the required configuration to produce an
 * Artifact for a Git repository.
 *
 * @schema GitRepositoryV1Beta2Spec
 */
export interface GitRepositoryV1Beta2Spec {
  /**
   * AccessFrom specifies an Access Control List for allowing cross-namespace
   * references to this object.
   * NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
   *
   * @schema GitRepositoryV1Beta2Spec#accessFrom
   */
  readonly accessFrom?: GitRepositoryV1Beta2SpecAccessFrom;

  /**
   * GitImplementation specifies which Git client library implementation to
   * use. Defaults to 'go-git', valid values are ('go-git', 'libgit2').
   * Deprecated: gitImplementation is deprecated now that 'go-git' is the
   * only supported implementation.
   *
   * @default go-git', valid values are ('go-git', 'libgit2').
   * @schema GitRepositoryV1Beta2Spec#gitImplementation
   */
  readonly gitImplementation?: GitRepositoryV1Beta2SpecGitImplementation;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format
   * (which is the same as .gitignore). If not provided, a default will be used,
   * consult the documentation for your version to find out what those are.
   *
   * @schema GitRepositoryV1Beta2Spec#ignore
   */
  readonly ignore?: string;

  /**
   * Include specifies a list of GitRepository resources which Artifacts
   * should be included in the Artifact produced for this GitRepository.
   *
   * @schema GitRepositoryV1Beta2Spec#include
   */
  readonly include?: GitRepositoryV1Beta2SpecInclude[];

  /**
   * Interval at which to check the GitRepository for updates.
   *
   * @schema GitRepositoryV1Beta2Spec#interval
   */
  readonly interval: string;

  /**
   * RecurseSubmodules enables the initialization of all submodules within
   * the GitRepository as cloned from the URL, using their default settings.
   *
   * @schema GitRepositoryV1Beta2Spec#recurseSubmodules
   */
  readonly recurseSubmodules?: boolean;

  /**
   * Reference specifies the Git reference to resolve and monitor for
   * changes, defaults to the 'master' branch.
   *
   * @schema GitRepositoryV1Beta2Spec#ref
   */
  readonly ref?: GitRepositoryV1Beta2SpecRef;

  /**
   * SecretRef specifies the Secret containing authentication credentials for
   * the GitRepository.
   * For HTTPS repositories the Secret must contain 'username' and 'password'
   * fields for basic auth or 'bearerToken' field for token auth.
   * For SSH repositories the Secret must contain 'identity'
   * and 'known_hosts' fields.
   *
   * @schema GitRepositoryV1Beta2Spec#secretRef
   */
  readonly secretRef?: GitRepositoryV1Beta2SpecSecretRef;

  /**
   * Suspend tells the controller to suspend the reconciliation of this
   * GitRepository.
   *
   * @schema GitRepositoryV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for Git operations like cloning, defaults to 60s.
   *
   * @schema GitRepositoryV1Beta2Spec#timeout
   */
  readonly timeout?: string;

  /**
   * URL specifies the Git repository URL, it can be an HTTP/S or SSH address.
   *
   * @schema GitRepositoryV1Beta2Spec#url
   */
  readonly url: string;

  /**
   * Verification specifies the configuration to verify the Git commit
   * signature(s).
   *
   * @schema GitRepositoryV1Beta2Spec#verify
   */
  readonly verify?: GitRepositoryV1Beta2SpecVerify;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta2Spec(obj: GitRepositoryV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_GitRepositoryV1Beta2SpecAccessFrom(obj.accessFrom),
    'gitImplementation': obj.gitImplementation,
    'ignore': obj.ignore,
    'include': obj.include?.map(y => toJson_GitRepositoryV1Beta2SpecInclude(y)),
    'interval': obj.interval,
    'recurseSubmodules': obj.recurseSubmodules,
    'ref': toJson_GitRepositoryV1Beta2SpecRef(obj.ref),
    'secretRef': toJson_GitRepositoryV1Beta2SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
    'verify': toJson_GitRepositoryV1Beta2SpecVerify(obj.verify),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom specifies an Access Control List for allowing cross-namespace
 * references to this object.
 * NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
 *
 * @schema GitRepositoryV1Beta2SpecAccessFrom
 */
export interface GitRepositoryV1Beta2SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema GitRepositoryV1Beta2SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta2SpecAccessFrom(obj: GitRepositoryV1Beta2SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitImplementation specifies which Git client library implementation to
 * use. Defaults to 'go-git', valid values are ('go-git', 'libgit2').
 * Deprecated: gitImplementation is deprecated now that 'go-git' is the
 * only supported implementation.
 *
 * @default go-git', valid values are ('go-git', 'libgit2').
 * @schema GitRepositoryV1Beta2SpecGitImplementation
 */
export enum GitRepositoryV1Beta2SpecGitImplementation {
  /** go-git */
  GO_HYPHEN_GIT = "go-git",
  /** libgit2 */
  LIBGIT2 = "libgit2",
}

/**
 * GitRepositoryInclude specifies a local reference to a GitRepository which
 * Artifact (sub-)contents must be included, and where they should be placed.
 *
 * @schema GitRepositoryV1Beta2SpecInclude
 */
export interface GitRepositoryV1Beta2SpecInclude {
  /**
   * FromPath specifies the path to copy contents from, defaults to the root
   * of the Artifact.
   *
   * @schema GitRepositoryV1Beta2SpecInclude#fromPath
   */
  readonly fromPath?: string;

  /**
   * GitRepositoryRef specifies the GitRepository which Artifact contents
   * must be included.
   *
   * @schema GitRepositoryV1Beta2SpecInclude#repository
   */
  readonly repository: GitRepositoryV1Beta2SpecIncludeRepository;

  /**
   * ToPath specifies the path to copy contents to, defaults to the name of
   * the GitRepositoryRef.
   *
   * @schema GitRepositoryV1Beta2SpecInclude#toPath
   */
  readonly toPath?: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecInclude' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta2SpecInclude(obj: GitRepositoryV1Beta2SpecInclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPath': obj.fromPath,
    'repository': toJson_GitRepositoryV1Beta2SpecIncludeRepository(obj.repository),
    'toPath': obj.toPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference specifies the Git reference to resolve and monitor for
 * changes, defaults to the 'master' branch.
 *
 * @schema GitRepositoryV1Beta2SpecRef
 */
export interface GitRepositoryV1Beta2SpecRef {
  /**
   * Branch to check out, defaults to 'master' if no other field is defined.
   *
   * @schema GitRepositoryV1Beta2SpecRef#branch
   */
  readonly branch?: string;

  /**
   * Commit SHA to check out, takes precedence over all reference fields.
   *
   * This can be combined with Branch to shallow clone the branch, in which
   * the commit is expected to exist.
   *
   * @schema GitRepositoryV1Beta2SpecRef#commit
   */
  readonly commit?: string;

  /**
   * Name of the reference to check out; takes precedence over Branch, Tag and SemVer.
   *
   * It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description
   * Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
   *
   * @schema GitRepositoryV1Beta2SpecRef#name
   */
  readonly name?: string;

  /**
   * SemVer tag expression to check out, takes precedence over Tag.
   *
   * @schema GitRepositoryV1Beta2SpecRef#semver
   */
  readonly semver?: string;

  /**
   * Tag to check out, takes precedence over Branch.
   *
   * @schema GitRepositoryV1Beta2SpecRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta2SpecRef(obj: GitRepositoryV1Beta2SpecRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commit': obj.commit,
    'name': obj.name,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef specifies the Secret containing authentication credentials for
 * the GitRepository.
 * For HTTPS repositories the Secret must contain 'username' and 'password'
 * fields for basic auth or 'bearerToken' field for token auth.
 * For SSH repositories the Secret must contain 'identity'
 * and 'known_hosts' fields.
 *
 * @schema GitRepositoryV1Beta2SpecSecretRef
 */
export interface GitRepositoryV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta2SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta2SpecSecretRef(obj: GitRepositoryV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Verification specifies the configuration to verify the Git commit
 * signature(s).
 *
 * @schema GitRepositoryV1Beta2SpecVerify
 */
export interface GitRepositoryV1Beta2SpecVerify {
  /**
   * Mode specifies what Git object should be verified, currently ('head').
   *
   * @schema GitRepositoryV1Beta2SpecVerify#mode
   */
  readonly mode: GitRepositoryV1Beta2SpecVerifyMode;

  /**
   * SecretRef specifies the Secret containing the public keys of trusted Git
   * authors.
   *
   * @schema GitRepositoryV1Beta2SpecVerify#secretRef
   */
  readonly secretRef: GitRepositoryV1Beta2SpecVerifySecretRef;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecVerify' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta2SpecVerify(obj: GitRepositoryV1Beta2SpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'secretRef': toJson_GitRepositoryV1Beta2SpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors
 */
export interface GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors(obj: GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitRepositoryRef specifies the GitRepository which Artifact contents
 * must be included.
 *
 * @schema GitRepositoryV1Beta2SpecIncludeRepository
 */
export interface GitRepositoryV1Beta2SpecIncludeRepository {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta2SpecIncludeRepository#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecIncludeRepository' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta2SpecIncludeRepository(obj: GitRepositoryV1Beta2SpecIncludeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode specifies what Git object should be verified, currently ('head').
 *
 * @schema GitRepositoryV1Beta2SpecVerifyMode
 */
export enum GitRepositoryV1Beta2SpecVerifyMode {
  /** head */
  HEAD = "head",
}

/**
 * SecretRef specifies the Secret containing the public keys of trusted Git
 * authors.
 *
 * @schema GitRepositoryV1Beta2SpecVerifySecretRef
 */
export interface GitRepositoryV1Beta2SpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta2SpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryV1Beta2SpecVerifySecretRef(obj: GitRepositoryV1Beta2SpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * HelmChart is the Schema for the helmcharts API.
 *
 * @schema HelmChart
 */
export class HelmChart extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmChart"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1',
    kind: 'HelmChart',
  }

  /**
   * Renders a Kubernetes manifest for "HelmChart".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmChartProps = {}): any {
    return {
      ...HelmChart.GVK,
      ...toJson_HelmChartProps(props),
    };
  }

  /**
   * Defines a "HelmChart" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmChartProps = {}) {
    super(scope, id, {
      ...HelmChart.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmChart.GVK,
      ...toJson_HelmChartProps(resolved),
    };
  }
}

/**
 * HelmChart is the Schema for the helmcharts API.
 *
 * @schema HelmChart
 */
export interface HelmChartProps {
  /**
   * @schema HelmChart#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmChartSpec specifies the desired state of a Helm chart.
   *
   * @schema HelmChart#spec
   */
  readonly spec?: HelmChartSpec;

}

/**
 * Converts an object of type 'HelmChartProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartProps(obj: HelmChartProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmChartSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HelmChartSpec specifies the desired state of a Helm chart.
 *
 * @schema HelmChartSpec
 */
export interface HelmChartSpec {
  /**
   * Chart is the name or path the Helm chart is available at in the
   * SourceRef.
   *
   * @schema HelmChartSpec#chart
   */
  readonly chart: string;

  /**
   * IgnoreMissingValuesFiles controls whether to silently ignore missing values
   * files rather than failing.
   *
   * @schema HelmChartSpec#ignoreMissingValuesFiles
   */
  readonly ignoreMissingValuesFiles?: boolean;

  /**
   * Interval at which the HelmChart SourceRef is checked for updates.
   * This interval is approximate and may be subject to jitter to ensure
   * efficient use of resources.
   *
   * @schema HelmChartSpec#interval
   */
  readonly interval: string;

  /**
   * ReconcileStrategy determines what enables the creation of a new artifact.
   * Valid values are ('ChartVersion', 'Revision').
   * See the documentation of the values for an explanation on their behavior.
   * Defaults to ChartVersion when omitted.
   *
   * @default ChartVersion when omitted.
   * @schema HelmChartSpec#reconcileStrategy
   */
  readonly reconcileStrategy?: HelmChartSpecReconcileStrategy;

  /**
   * SourceRef is the reference to the Source the chart is available at.
   *
   * @schema HelmChartSpec#sourceRef
   */
  readonly sourceRef: HelmChartSpecSourceRef;

  /**
   * Suspend tells the controller to suspend the reconciliation of this
   * source.
   *
   * @schema HelmChartSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * ValuesFiles is an alternative list of values files to use as the chart
   * values (values.yaml is not included by default), expected to be a
   * relative path in the SourceRef.
   * Values files are merged in the order of this list with the last file
   * overriding the first. Ignored when omitted.
   *
   * @schema HelmChartSpec#valuesFiles
   */
  readonly valuesFiles?: string[];

  /**
   * Verify contains the secret name containing the trusted public keys
   * used to verify the signature and specifies which provider to use to check
   * whether OCI image is authentic.
   * This field is only supported when using HelmRepository source with spec.type 'oci'.
   * Chart dependencies, which are not bundled in the umbrella chart artifact, are not verified.
   *
   * @schema HelmChartSpec#verify
   */
  readonly verify?: HelmChartSpecVerify;

  /**
   * Version is the chart version semver expression, ignored for charts from
   * GitRepository and Bucket sources. Defaults to latest when omitted.
   *
   * @default latest when omitted.
   * @schema HelmChartSpec#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'HelmChartSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartSpec(obj: HelmChartSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chart': obj.chart,
    'ignoreMissingValuesFiles': obj.ignoreMissingValuesFiles,
    'interval': obj.interval,
    'reconcileStrategy': obj.reconcileStrategy,
    'sourceRef': toJson_HelmChartSpecSourceRef(obj.sourceRef),
    'suspend': obj.suspend,
    'valuesFiles': obj.valuesFiles?.map(y => y),
    'verify': toJson_HelmChartSpecVerify(obj.verify),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReconcileStrategy determines what enables the creation of a new artifact.
 * Valid values are ('ChartVersion', 'Revision').
 * See the documentation of the values for an explanation on their behavior.
 * Defaults to ChartVersion when omitted.
 *
 * @default ChartVersion when omitted.
 * @schema HelmChartSpecReconcileStrategy
 */
export enum HelmChartSpecReconcileStrategy {
  /** ChartVersion */
  CHART_VERSION = "ChartVersion",
  /** Revision */
  REVISION = "Revision",
}

/**
 * SourceRef is the reference to the Source the chart is available at.
 *
 * @schema HelmChartSpecSourceRef
 */
export interface HelmChartSpecSourceRef {
  /**
   * APIVersion of the referent.
   *
   * @schema HelmChartSpecSourceRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
   * 'Bucket').
   *
   * @schema HelmChartSpecSourceRef#kind
   */
  readonly kind: HelmChartSpecSourceRefKind;

  /**
   * Name of the referent.
   *
   * @schema HelmChartSpecSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmChartSpecSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartSpecSourceRef(obj: HelmChartSpecSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Verify contains the secret name containing the trusted public keys
 * used to verify the signature and specifies which provider to use to check
 * whether OCI image is authentic.
 * This field is only supported when using HelmRepository source with spec.type 'oci'.
 * Chart dependencies, which are not bundled in the umbrella chart artifact, are not verified.
 *
 * @schema HelmChartSpecVerify
 */
export interface HelmChartSpecVerify {
  /**
   * MatchOIDCIdentity specifies the identity matching criteria to use
   * while verifying an OCI artifact which was signed using Cosign keyless
   * signing. The artifact's identity is deemed to be verified if any of the
   * specified matchers match against the identity.
   *
   * @schema HelmChartSpecVerify#matchOIDCIdentity
   */
  readonly matchOidcIdentity?: HelmChartSpecVerifyMatchOidcIdentity[];

  /**
   * Provider specifies the technology used to sign the OCI Artifact.
   *
   * @schema HelmChartSpecVerify#provider
   */
  readonly provider: HelmChartSpecVerifyProvider;

  /**
   * SecretRef specifies the Kubernetes Secret containing the
   * trusted public keys.
   *
   * @schema HelmChartSpecVerify#secretRef
   */
  readonly secretRef?: HelmChartSpecVerifySecretRef;

}

/**
 * Converts an object of type 'HelmChartSpecVerify' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartSpecVerify(obj: HelmChartSpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchOIDCIdentity': obj.matchOidcIdentity?.map(y => toJson_HelmChartSpecVerifyMatchOidcIdentity(y)),
    'provider': obj.provider,
    'secretRef': toJson_HelmChartSpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
 * 'Bucket').
 *
 * @schema HelmChartSpecSourceRefKind
 */
export enum HelmChartSpecSourceRefKind {
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Bucket */
  BUCKET = "Bucket",
}

/**
 * OIDCIdentityMatch specifies options for verifying the certificate identity,
 * i.e. the issuer and the subject of the certificate.
 *
 * @schema HelmChartSpecVerifyMatchOidcIdentity
 */
export interface HelmChartSpecVerifyMatchOidcIdentity {
  /**
   * Issuer specifies the regex pattern to match against to verify
   * the OIDC issuer in the Fulcio certificate. The pattern must be a
   * valid Go regular expression.
   *
   * @schema HelmChartSpecVerifyMatchOidcIdentity#issuer
   */
  readonly issuer: string;

  /**
   * Subject specifies the regex pattern to match against to verify
   * the identity subject in the Fulcio certificate. The pattern must
   * be a valid Go regular expression.
   *
   * @schema HelmChartSpecVerifyMatchOidcIdentity#subject
   */
  readonly subject: string;

}

/**
 * Converts an object of type 'HelmChartSpecVerifyMatchOidcIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartSpecVerifyMatchOidcIdentity(obj: HelmChartSpecVerifyMatchOidcIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issuer': obj.issuer,
    'subject': obj.subject,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider specifies the technology used to sign the OCI Artifact.
 *
 * @schema HelmChartSpecVerifyProvider
 */
export enum HelmChartSpecVerifyProvider {
  /** cosign */
  COSIGN = "cosign",
  /** notation */
  NOTATION = "notation",
}

/**
 * SecretRef specifies the Kubernetes Secret containing the
 * trusted public keys.
 *
 * @schema HelmChartSpecVerifySecretRef
 */
export interface HelmChartSpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema HelmChartSpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmChartSpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartSpecVerifySecretRef(obj: HelmChartSpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * HelmChart is the Schema for the helmcharts API
 *
 * @schema HelmChartV1Beta1
 */
export class HelmChartV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmChartV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'HelmChart',
  }

  /**
   * Renders a Kubernetes manifest for "HelmChartV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmChartV1Beta1Props = {}): any {
    return {
      ...HelmChartV1Beta1.GVK,
      ...toJson_HelmChartV1Beta1Props(props),
    };
  }

  /**
   * Defines a "HelmChartV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmChartV1Beta1Props = {}) {
    super(scope, id, {
      ...HelmChartV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmChartV1Beta1.GVK,
      ...toJson_HelmChartV1Beta1Props(resolved),
    };
  }
}

/**
 * HelmChart is the Schema for the helmcharts API
 *
 * @schema HelmChartV1Beta1
 */
export interface HelmChartV1Beta1Props {
  /**
   * @schema HelmChartV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmChartSpec defines the desired state of a Helm chart.
   *
   * @schema HelmChartV1Beta1#spec
   */
  readonly spec?: HelmChartV1Beta1Spec;

}

/**
 * Converts an object of type 'HelmChartV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta1Props(obj: HelmChartV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmChartV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HelmChartSpec defines the desired state of a Helm chart.
 *
 * @schema HelmChartV1Beta1Spec
 */
export interface HelmChartV1Beta1Spec {
  /**
   * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
   *
   * @schema HelmChartV1Beta1Spec#accessFrom
   */
  readonly accessFrom?: HelmChartV1Beta1SpecAccessFrom;

  /**
   * The name or path the Helm chart is available at in the SourceRef.
   *
   * @schema HelmChartV1Beta1Spec#chart
   */
  readonly chart: string;

  /**
   * The interval at which to check the Source for updates.
   *
   * @schema HelmChartV1Beta1Spec#interval
   */
  readonly interval: string;

  /**
   * Determines what enables the creation of a new artifact. Valid values are
   * ('ChartVersion', 'Revision').
   * See the documentation of the values for an explanation on their behavior.
   * Defaults to ChartVersion when omitted.
   *
   * @default ChartVersion when omitted.
   * @schema HelmChartV1Beta1Spec#reconcileStrategy
   */
  readonly reconcileStrategy?: HelmChartV1Beta1SpecReconcileStrategy;

  /**
   * The reference to the Source the chart is available at.
   *
   * @schema HelmChartV1Beta1Spec#sourceRef
   */
  readonly sourceRef: HelmChartV1Beta1SpecSourceRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema HelmChartV1Beta1Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Alternative values file to use as the default chart values, expected to
   * be a relative path in the SourceRef. Deprecated in favor of ValuesFiles,
   * for backwards compatibility the file defined here is merged before the
   * ValuesFiles items. Ignored when omitted.
   *
   * @schema HelmChartV1Beta1Spec#valuesFile
   */
  readonly valuesFile?: string;

  /**
   * Alternative list of values files to use as the chart values (values.yaml
   * is not included by default), expected to be a relative path in the SourceRef.
   * Values files are merged in the order of this list with the last file overriding
   * the first. Ignored when omitted.
   *
   * @schema HelmChartV1Beta1Spec#valuesFiles
   */
  readonly valuesFiles?: string[];

  /**
   * The chart version semver expression, ignored for charts from GitRepository
   * and Bucket sources. Defaults to latest when omitted.
   *
   * @default latest when omitted.
   * @schema HelmChartV1Beta1Spec#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'HelmChartV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta1Spec(obj: HelmChartV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_HelmChartV1Beta1SpecAccessFrom(obj.accessFrom),
    'chart': obj.chart,
    'interval': obj.interval,
    'reconcileStrategy': obj.reconcileStrategy,
    'sourceRef': toJson_HelmChartV1Beta1SpecSourceRef(obj.sourceRef),
    'suspend': obj.suspend,
    'valuesFile': obj.valuesFile,
    'valuesFiles': obj.valuesFiles?.map(y => y),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
 *
 * @schema HelmChartV1Beta1SpecAccessFrom
 */
export interface HelmChartV1Beta1SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema HelmChartV1Beta1SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: HelmChartV1Beta1SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'HelmChartV1Beta1SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta1SpecAccessFrom(obj: HelmChartV1Beta1SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_HelmChartV1Beta1SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Determines what enables the creation of a new artifact. Valid values are
 * ('ChartVersion', 'Revision').
 * See the documentation of the values for an explanation on their behavior.
 * Defaults to ChartVersion when omitted.
 *
 * @default ChartVersion when omitted.
 * @schema HelmChartV1Beta1SpecReconcileStrategy
 */
export enum HelmChartV1Beta1SpecReconcileStrategy {
  /** ChartVersion */
  CHART_VERSION = "ChartVersion",
  /** Revision */
  REVISION = "Revision",
}

/**
 * The reference to the Source the chart is available at.
 *
 * @schema HelmChartV1Beta1SpecSourceRef
 */
export interface HelmChartV1Beta1SpecSourceRef {
  /**
   * APIVersion of the referent.
   *
   * @schema HelmChartV1Beta1SpecSourceRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
   * 'Bucket').
   *
   * @schema HelmChartV1Beta1SpecSourceRef#kind
   */
  readonly kind: HelmChartV1Beta1SpecSourceRefKind;

  /**
   * Name of the referent.
   *
   * @schema HelmChartV1Beta1SpecSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmChartV1Beta1SpecSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta1SpecSourceRef(obj: HelmChartV1Beta1SpecSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema HelmChartV1Beta1SpecAccessFromNamespaceSelectors
 */
export interface HelmChartV1Beta1SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema HelmChartV1Beta1SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'HelmChartV1Beta1SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta1SpecAccessFromNamespaceSelectors(obj: HelmChartV1Beta1SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
 * 'Bucket').
 *
 * @schema HelmChartV1Beta1SpecSourceRefKind
 */
export enum HelmChartV1Beta1SpecSourceRefKind {
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Bucket */
  BUCKET = "Bucket",
}


/**
 * HelmChart is the Schema for the helmcharts API.
 *
 * @schema HelmChartV1Beta2
 */
export class HelmChartV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmChartV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta2',
    kind: 'HelmChart',
  }

  /**
   * Renders a Kubernetes manifest for "HelmChartV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmChartV1Beta2Props = {}): any {
    return {
      ...HelmChartV1Beta2.GVK,
      ...toJson_HelmChartV1Beta2Props(props),
    };
  }

  /**
   * Defines a "HelmChartV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmChartV1Beta2Props = {}) {
    super(scope, id, {
      ...HelmChartV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmChartV1Beta2.GVK,
      ...toJson_HelmChartV1Beta2Props(resolved),
    };
  }
}

/**
 * HelmChart is the Schema for the helmcharts API.
 *
 * @schema HelmChartV1Beta2
 */
export interface HelmChartV1Beta2Props {
  /**
   * @schema HelmChartV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmChartSpec specifies the desired state of a Helm chart.
   *
   * @schema HelmChartV1Beta2#spec
   */
  readonly spec?: HelmChartV1Beta2Spec;

}

/**
 * Converts an object of type 'HelmChartV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta2Props(obj: HelmChartV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmChartV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HelmChartSpec specifies the desired state of a Helm chart.
 *
 * @schema HelmChartV1Beta2Spec
 */
export interface HelmChartV1Beta2Spec {
  /**
   * AccessFrom specifies an Access Control List for allowing cross-namespace
   * references to this object.
   * NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
   *
   * @schema HelmChartV1Beta2Spec#accessFrom
   */
  readonly accessFrom?: HelmChartV1Beta2SpecAccessFrom;

  /**
   * Chart is the name or path the Helm chart is available at in the
   * SourceRef.
   *
   * @schema HelmChartV1Beta2Spec#chart
   */
  readonly chart: string;

  /**
   * IgnoreMissingValuesFiles controls whether to silently ignore missing values
   * files rather than failing.
   *
   * @schema HelmChartV1Beta2Spec#ignoreMissingValuesFiles
   */
  readonly ignoreMissingValuesFiles?: boolean;

  /**
   * Interval at which the HelmChart SourceRef is checked for updates.
   * This interval is approximate and may be subject to jitter to ensure
   * efficient use of resources.
   *
   * @schema HelmChartV1Beta2Spec#interval
   */
  readonly interval: string;

  /**
   * ReconcileStrategy determines what enables the creation of a new artifact.
   * Valid values are ('ChartVersion', 'Revision').
   * See the documentation of the values for an explanation on their behavior.
   * Defaults to ChartVersion when omitted.
   *
   * @default ChartVersion when omitted.
   * @schema HelmChartV1Beta2Spec#reconcileStrategy
   */
  readonly reconcileStrategy?: HelmChartV1Beta2SpecReconcileStrategy;

  /**
   * SourceRef is the reference to the Source the chart is available at.
   *
   * @schema HelmChartV1Beta2Spec#sourceRef
   */
  readonly sourceRef: HelmChartV1Beta2SpecSourceRef;

  /**
   * Suspend tells the controller to suspend the reconciliation of this
   * source.
   *
   * @schema HelmChartV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * ValuesFile is an alternative values file to use as the default chart
   * values, expected to be a relative path in the SourceRef. Deprecated in
   * favor of ValuesFiles, for backwards compatibility the file specified here
   * is merged before the ValuesFiles items. Ignored when omitted.
   *
   * @schema HelmChartV1Beta2Spec#valuesFile
   */
  readonly valuesFile?: string;

  /**
   * ValuesFiles is an alternative list of values files to use as the chart
   * values (values.yaml is not included by default), expected to be a
   * relative path in the SourceRef.
   * Values files are merged in the order of this list with the last file
   * overriding the first. Ignored when omitted.
   *
   * @schema HelmChartV1Beta2Spec#valuesFiles
   */
  readonly valuesFiles?: string[];

  /**
   * Verify contains the secret name containing the trusted public keys
   * used to verify the signature and specifies which provider to use to check
   * whether OCI image is authentic.
   * This field is only supported when using HelmRepository source with spec.type 'oci'.
   * Chart dependencies, which are not bundled in the umbrella chart artifact, are not verified.
   *
   * @schema HelmChartV1Beta2Spec#verify
   */
  readonly verify?: HelmChartV1Beta2SpecVerify;

  /**
   * Version is the chart version semver expression, ignored for charts from
   * GitRepository and Bucket sources. Defaults to latest when omitted.
   *
   * @default latest when omitted.
   * @schema HelmChartV1Beta2Spec#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'HelmChartV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta2Spec(obj: HelmChartV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_HelmChartV1Beta2SpecAccessFrom(obj.accessFrom),
    'chart': obj.chart,
    'ignoreMissingValuesFiles': obj.ignoreMissingValuesFiles,
    'interval': obj.interval,
    'reconcileStrategy': obj.reconcileStrategy,
    'sourceRef': toJson_HelmChartV1Beta2SpecSourceRef(obj.sourceRef),
    'suspend': obj.suspend,
    'valuesFile': obj.valuesFile,
    'valuesFiles': obj.valuesFiles?.map(y => y),
    'verify': toJson_HelmChartV1Beta2SpecVerify(obj.verify),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom specifies an Access Control List for allowing cross-namespace
 * references to this object.
 * NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
 *
 * @schema HelmChartV1Beta2SpecAccessFrom
 */
export interface HelmChartV1Beta2SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema HelmChartV1Beta2SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: HelmChartV1Beta2SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta2SpecAccessFrom(obj: HelmChartV1Beta2SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_HelmChartV1Beta2SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReconcileStrategy determines what enables the creation of a new artifact.
 * Valid values are ('ChartVersion', 'Revision').
 * See the documentation of the values for an explanation on their behavior.
 * Defaults to ChartVersion when omitted.
 *
 * @default ChartVersion when omitted.
 * @schema HelmChartV1Beta2SpecReconcileStrategy
 */
export enum HelmChartV1Beta2SpecReconcileStrategy {
  /** ChartVersion */
  CHART_VERSION = "ChartVersion",
  /** Revision */
  REVISION = "Revision",
}

/**
 * SourceRef is the reference to the Source the chart is available at.
 *
 * @schema HelmChartV1Beta2SpecSourceRef
 */
export interface HelmChartV1Beta2SpecSourceRef {
  /**
   * APIVersion of the referent.
   *
   * @schema HelmChartV1Beta2SpecSourceRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
   * 'Bucket').
   *
   * @schema HelmChartV1Beta2SpecSourceRef#kind
   */
  readonly kind: HelmChartV1Beta2SpecSourceRefKind;

  /**
   * Name of the referent.
   *
   * @schema HelmChartV1Beta2SpecSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta2SpecSourceRef(obj: HelmChartV1Beta2SpecSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Verify contains the secret name containing the trusted public keys
 * used to verify the signature and specifies which provider to use to check
 * whether OCI image is authentic.
 * This field is only supported when using HelmRepository source with spec.type 'oci'.
 * Chart dependencies, which are not bundled in the umbrella chart artifact, are not verified.
 *
 * @schema HelmChartV1Beta2SpecVerify
 */
export interface HelmChartV1Beta2SpecVerify {
  /**
   * MatchOIDCIdentity specifies the identity matching criteria to use
   * while verifying an OCI artifact which was signed using Cosign keyless
   * signing. The artifact's identity is deemed to be verified if any of the
   * specified matchers match against the identity.
   *
   * @schema HelmChartV1Beta2SpecVerify#matchOIDCIdentity
   */
  readonly matchOidcIdentity?: HelmChartV1Beta2SpecVerifyMatchOidcIdentity[];

  /**
   * Provider specifies the technology used to sign the OCI Artifact.
   *
   * @schema HelmChartV1Beta2SpecVerify#provider
   */
  readonly provider: HelmChartV1Beta2SpecVerifyProvider;

  /**
   * SecretRef specifies the Kubernetes Secret containing the
   * trusted public keys.
   *
   * @schema HelmChartV1Beta2SpecVerify#secretRef
   */
  readonly secretRef?: HelmChartV1Beta2SpecVerifySecretRef;

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecVerify' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta2SpecVerify(obj: HelmChartV1Beta2SpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchOIDCIdentity': obj.matchOidcIdentity?.map(y => toJson_HelmChartV1Beta2SpecVerifyMatchOidcIdentity(y)),
    'provider': obj.provider,
    'secretRef': toJson_HelmChartV1Beta2SpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema HelmChartV1Beta2SpecAccessFromNamespaceSelectors
 */
export interface HelmChartV1Beta2SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema HelmChartV1Beta2SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta2SpecAccessFromNamespaceSelectors(obj: HelmChartV1Beta2SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
 * 'Bucket').
 *
 * @schema HelmChartV1Beta2SpecSourceRefKind
 */
export enum HelmChartV1Beta2SpecSourceRefKind {
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Bucket */
  BUCKET = "Bucket",
}

/**
 * OIDCIdentityMatch specifies options for verifying the certificate identity,
 * i.e. the issuer and the subject of the certificate.
 *
 * @schema HelmChartV1Beta2SpecVerifyMatchOidcIdentity
 */
export interface HelmChartV1Beta2SpecVerifyMatchOidcIdentity {
  /**
   * Issuer specifies the regex pattern to match against to verify
   * the OIDC issuer in the Fulcio certificate. The pattern must be a
   * valid Go regular expression.
   *
   * @schema HelmChartV1Beta2SpecVerifyMatchOidcIdentity#issuer
   */
  readonly issuer: string;

  /**
   * Subject specifies the regex pattern to match against to verify
   * the identity subject in the Fulcio certificate. The pattern must
   * be a valid Go regular expression.
   *
   * @schema HelmChartV1Beta2SpecVerifyMatchOidcIdentity#subject
   */
  readonly subject: string;

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecVerifyMatchOidcIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta2SpecVerifyMatchOidcIdentity(obj: HelmChartV1Beta2SpecVerifyMatchOidcIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issuer': obj.issuer,
    'subject': obj.subject,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider specifies the technology used to sign the OCI Artifact.
 *
 * @schema HelmChartV1Beta2SpecVerifyProvider
 */
export enum HelmChartV1Beta2SpecVerifyProvider {
  /** cosign */
  COSIGN = "cosign",
  /** notation */
  NOTATION = "notation",
}

/**
 * SecretRef specifies the Kubernetes Secret containing the
 * trusted public keys.
 *
 * @schema HelmChartV1Beta2SpecVerifySecretRef
 */
export interface HelmChartV1Beta2SpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema HelmChartV1Beta2SpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmChartV1Beta2SpecVerifySecretRef(obj: HelmChartV1Beta2SpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * HelmRepository is the Schema for the helmrepositories API.
 *
 * @schema HelmRepository
 */
export class HelmRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1',
    kind: 'HelmRepository',
  }

  /**
   * Renders a Kubernetes manifest for "HelmRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmRepositoryProps = {}): any {
    return {
      ...HelmRepository.GVK,
      ...toJson_HelmRepositoryProps(props),
    };
  }

  /**
   * Defines a "HelmRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmRepositoryProps = {}) {
    super(scope, id, {
      ...HelmRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmRepository.GVK,
      ...toJson_HelmRepositoryProps(resolved),
    };
  }
}

/**
 * HelmRepository is the Schema for the helmrepositories API.
 *
 * @schema HelmRepository
 */
export interface HelmRepositoryProps {
  /**
   * @schema HelmRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmRepositorySpec specifies the required configuration to produce an
   * Artifact for a Helm repository index YAML.
   *
   * @schema HelmRepository#spec
   */
  readonly spec?: HelmRepositorySpec;

}

/**
 * Converts an object of type 'HelmRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryProps(obj: HelmRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HelmRepositorySpec specifies the required configuration to produce an
 * Artifact for a Helm repository index YAML.
 *
 * @schema HelmRepositorySpec
 */
export interface HelmRepositorySpec {
  /**
   * AccessFrom specifies an Access Control List for allowing cross-namespace
   * references to this object.
   * NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
   *
   * @schema HelmRepositorySpec#accessFrom
   */
  readonly accessFrom?: HelmRepositorySpecAccessFrom;

  /**
   * CertSecretRef can be given the name of a Secret containing
   * either or both of
   *
   * - a PEM-encoded client certificate (`tls.crt`) and private
   * key (`tls.key`);
   * - a PEM-encoded CA certificate (`ca.crt`)
   *
   * and whichever are supplied, will be used for connecting to the
   * registry. The client cert and key are useful if you are
   * authenticating with a certificate; the CA cert is useful if
   * you are using a self-signed server certificate. The Secret must
   * be of type `Opaque` or `kubernetes.io/tls`.
   *
   * It takes precedence over the values specified in the Secret referred
   * to by `.spec.secretRef`.
   *
   * @schema HelmRepositorySpec#certSecretRef
   */
  readonly certSecretRef?: HelmRepositorySpecCertSecretRef;

  /**
   * Insecure allows connecting to a non-TLS HTTP container registry.
   * This field is only taken into account if the .spec.type field is set to 'oci'.
   *
   * @schema HelmRepositorySpec#insecure
   */
  readonly insecure?: boolean;

  /**
   * Interval at which the HelmRepository URL is checked for updates.
   * This interval is approximate and may be subject to jitter to ensure
   * efficient use of resources.
   *
   * @schema HelmRepositorySpec#interval
   */
  readonly interval?: string;

  /**
   * PassCredentials allows the credentials from the SecretRef to be passed
   * on to a host that does not match the host as defined in URL.
   * This may be required if the host of the advertised chart URLs in the
   * index differ from the defined URL.
   * Enabling this should be done with caution, as it can potentially result
   * in credentials getting stolen in a MITM-attack.
   *
   * @schema HelmRepositorySpec#passCredentials
   */
  readonly passCredentials?: boolean;

  /**
   * Provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
   * This field is optional, and only taken into account if the .spec.type field is set to 'oci'.
   * When not specified, defaults to 'generic'.
   *
   * @schema HelmRepositorySpec#provider
   */
  readonly provider?: HelmRepositorySpecProvider;

  /**
   * SecretRef specifies the Secret containing authentication credentials
   * for the HelmRepository.
   * For HTTP/S basic auth the secret must contain 'username' and 'password'
   * fields.
   * Support for TLS auth using the 'certFile' and 'keyFile', and/or 'caFile'
   * keys is deprecated. Please use `.spec.certSecretRef` instead.
   *
   * @schema HelmRepositorySpec#secretRef
   */
  readonly secretRef?: HelmRepositorySpecSecretRef;

  /**
   * Suspend tells the controller to suspend the reconciliation of this
   * HelmRepository.
   *
   * @schema HelmRepositorySpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout is used for the index fetch operation for an HTTPS helm repository,
   * and for remote OCI Repository operations like pulling for an OCI helm
   * chart by the associated HelmChart.
   * Its default value is 60s.
   *
   * @schema HelmRepositorySpec#timeout
   */
  readonly timeout?: string;

  /**
   * Type of the HelmRepository.
   * When this field is set to  "oci", the URL field value must be prefixed with "oci://".
   *
   * @schema HelmRepositorySpec#type
   */
  readonly type?: HelmRepositorySpecType;

  /**
   * URL of the Helm repository, a valid URL contains at least a protocol and
   * host.
   *
   * @schema HelmRepositorySpec#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'HelmRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositorySpec(obj: HelmRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_HelmRepositorySpecAccessFrom(obj.accessFrom),
    'certSecretRef': toJson_HelmRepositorySpecCertSecretRef(obj.certSecretRef),
    'insecure': obj.insecure,
    'interval': obj.interval,
    'passCredentials': obj.passCredentials,
    'provider': obj.provider,
    'secretRef': toJson_HelmRepositorySpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'type': obj.type,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom specifies an Access Control List for allowing cross-namespace
 * references to this object.
 * NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
 *
 * @schema HelmRepositorySpecAccessFrom
 */
export interface HelmRepositorySpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema HelmRepositorySpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: HelmRepositorySpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'HelmRepositorySpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositorySpecAccessFrom(obj: HelmRepositorySpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_HelmRepositorySpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef can be given the name of a Secret containing
 * either or both of
 *
 * - a PEM-encoded client certificate (`tls.crt`) and private
 * key (`tls.key`);
 * - a PEM-encoded CA certificate (`ca.crt`)
 *
 * and whichever are supplied, will be used for connecting to the
 * registry. The client cert and key are useful if you are
 * authenticating with a certificate; the CA cert is useful if
 * you are using a self-signed server certificate. The Secret must
 * be of type `Opaque` or `kubernetes.io/tls`.
 *
 * It takes precedence over the values specified in the Secret referred
 * to by `.spec.secretRef`.
 *
 * @schema HelmRepositorySpecCertSecretRef
 */
export interface HelmRepositorySpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema HelmRepositorySpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmRepositorySpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositorySpecCertSecretRef(obj: HelmRepositorySpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
 * This field is optional, and only taken into account if the .spec.type field is set to 'oci'.
 * When not specified, defaults to 'generic'.
 *
 * @schema HelmRepositorySpecProvider
 */
export enum HelmRepositorySpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** azure */
  AZURE = "azure",
  /** gcp */
  GCP = "gcp",
}

/**
 * SecretRef specifies the Secret containing authentication credentials
 * for the HelmRepository.
 * For HTTP/S basic auth the secret must contain 'username' and 'password'
 * fields.
 * Support for TLS auth using the 'certFile' and 'keyFile', and/or 'caFile'
 * keys is deprecated. Please use `.spec.certSecretRef` instead.
 *
 * @schema HelmRepositorySpecSecretRef
 */
export interface HelmRepositorySpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema HelmRepositorySpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositorySpecSecretRef(obj: HelmRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of the HelmRepository.
 * When this field is set to  "oci", the URL field value must be prefixed with "oci://".
 *
 * @schema HelmRepositorySpecType
 */
export enum HelmRepositorySpecType {
  /** default */
  DEFAULT = "default",
  /** oci */
  OCI = "oci",
}

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema HelmRepositorySpecAccessFromNamespaceSelectors
 */
export interface HelmRepositorySpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema HelmRepositorySpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'HelmRepositorySpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositorySpecAccessFromNamespaceSelectors(obj: HelmRepositorySpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * HelmRepository is the Schema for the helmrepositories API
 *
 * @schema HelmRepositoryV1Beta1
 */
export class HelmRepositoryV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmRepositoryV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'HelmRepository',
  }

  /**
   * Renders a Kubernetes manifest for "HelmRepositoryV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmRepositoryV1Beta1Props = {}): any {
    return {
      ...HelmRepositoryV1Beta1.GVK,
      ...toJson_HelmRepositoryV1Beta1Props(props),
    };
  }

  /**
   * Defines a "HelmRepositoryV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmRepositoryV1Beta1Props = {}) {
    super(scope, id, {
      ...HelmRepositoryV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmRepositoryV1Beta1.GVK,
      ...toJson_HelmRepositoryV1Beta1Props(resolved),
    };
  }
}

/**
 * HelmRepository is the Schema for the helmrepositories API
 *
 * @schema HelmRepositoryV1Beta1
 */
export interface HelmRepositoryV1Beta1Props {
  /**
   * @schema HelmRepositoryV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmRepositorySpec defines the reference to a Helm repository.
   *
   * @schema HelmRepositoryV1Beta1#spec
   */
  readonly spec?: HelmRepositoryV1Beta1Spec;

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta1Props(obj: HelmRepositoryV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmRepositoryV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HelmRepositorySpec defines the reference to a Helm repository.
 *
 * @schema HelmRepositoryV1Beta1Spec
 */
export interface HelmRepositoryV1Beta1Spec {
  /**
   * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
   *
   * @schema HelmRepositoryV1Beta1Spec#accessFrom
   */
  readonly accessFrom?: HelmRepositoryV1Beta1SpecAccessFrom;

  /**
   * The interval at which to check the upstream for updates.
   *
   * @schema HelmRepositoryV1Beta1Spec#interval
   */
  readonly interval: string;

  /**
   * PassCredentials allows the credentials from the SecretRef to be passed on to
   * a host that does not match the host as defined in URL.
   * This may be required if the host of the advertised chart URLs in the index
   * differ from the defined URL.
   * Enabling this should be done with caution, as it can potentially result in
   * credentials getting stolen in a MITM-attack.
   *
   * @schema HelmRepositoryV1Beta1Spec#passCredentials
   */
  readonly passCredentials?: boolean;

  /**
   * The name of the secret containing authentication credentials for the Helm
   * repository.
   * For HTTP/S basic auth the secret must contain username and
   * password fields.
   * For TLS the secret must contain a certFile and keyFile, and/or
   * caFile fields.
   *
   * @schema HelmRepositoryV1Beta1Spec#secretRef
   */
  readonly secretRef?: HelmRepositoryV1Beta1SpecSecretRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema HelmRepositoryV1Beta1Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout of index downloading, defaults to 60s.
   *
   * @schema HelmRepositoryV1Beta1Spec#timeout
   */
  readonly timeout?: string;

  /**
   * The Helm repository URL, a valid URL contains at least a protocol and host.
   *
   * @schema HelmRepositoryV1Beta1Spec#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta1Spec(obj: HelmRepositoryV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_HelmRepositoryV1Beta1SpecAccessFrom(obj.accessFrom),
    'interval': obj.interval,
    'passCredentials': obj.passCredentials,
    'secretRef': toJson_HelmRepositoryV1Beta1SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
 *
 * @schema HelmRepositoryV1Beta1SpecAccessFrom
 */
export interface HelmRepositoryV1Beta1SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema HelmRepositoryV1Beta1SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: HelmRepositoryV1Beta1SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta1SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta1SpecAccessFrom(obj: HelmRepositoryV1Beta1SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_HelmRepositoryV1Beta1SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The name of the secret containing authentication credentials for the Helm
 * repository.
 * For HTTP/S basic auth the secret must contain username and
 * password fields.
 * For TLS the secret must contain a certFile and keyFile, and/or
 * caFile fields.
 *
 * @schema HelmRepositoryV1Beta1SpecSecretRef
 */
export interface HelmRepositoryV1Beta1SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema HelmRepositoryV1Beta1SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta1SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta1SpecSecretRef(obj: HelmRepositoryV1Beta1SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema HelmRepositoryV1Beta1SpecAccessFromNamespaceSelectors
 */
export interface HelmRepositoryV1Beta1SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema HelmRepositoryV1Beta1SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta1SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta1SpecAccessFromNamespaceSelectors(obj: HelmRepositoryV1Beta1SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * HelmRepository is the Schema for the helmrepositories API.
 *
 * @schema HelmRepositoryV1Beta2
 */
export class HelmRepositoryV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmRepositoryV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta2',
    kind: 'HelmRepository',
  }

  /**
   * Renders a Kubernetes manifest for "HelmRepositoryV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmRepositoryV1Beta2Props = {}): any {
    return {
      ...HelmRepositoryV1Beta2.GVK,
      ...toJson_HelmRepositoryV1Beta2Props(props),
    };
  }

  /**
   * Defines a "HelmRepositoryV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmRepositoryV1Beta2Props = {}) {
    super(scope, id, {
      ...HelmRepositoryV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmRepositoryV1Beta2.GVK,
      ...toJson_HelmRepositoryV1Beta2Props(resolved),
    };
  }
}

/**
 * HelmRepository is the Schema for the helmrepositories API.
 *
 * @schema HelmRepositoryV1Beta2
 */
export interface HelmRepositoryV1Beta2Props {
  /**
   * @schema HelmRepositoryV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmRepositorySpec specifies the required configuration to produce an
   * Artifact for a Helm repository index YAML.
   *
   * @schema HelmRepositoryV1Beta2#spec
   */
  readonly spec?: HelmRepositoryV1Beta2Spec;

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta2Props(obj: HelmRepositoryV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmRepositoryV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HelmRepositorySpec specifies the required configuration to produce an
 * Artifact for a Helm repository index YAML.
 *
 * @schema HelmRepositoryV1Beta2Spec
 */
export interface HelmRepositoryV1Beta2Spec {
  /**
   * AccessFrom specifies an Access Control List for allowing cross-namespace
   * references to this object.
   * NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
   *
   * @schema HelmRepositoryV1Beta2Spec#accessFrom
   */
  readonly accessFrom?: HelmRepositoryV1Beta2SpecAccessFrom;

  /**
   * CertSecretRef can be given the name of a Secret containing
   * either or both of
   *
   * - a PEM-encoded client certificate (`tls.crt`) and private
   * key (`tls.key`);
   * - a PEM-encoded CA certificate (`ca.crt`)
   *
   * and whichever are supplied, will be used for connecting to the
   * registry. The client cert and key are useful if you are
   * authenticating with a certificate; the CA cert is useful if
   * you are using a self-signed server certificate. The Secret must
   * be of type `Opaque` or `kubernetes.io/tls`.
   *
   * It takes precedence over the values specified in the Secret referred
   * to by `.spec.secretRef`.
   *
   * @schema HelmRepositoryV1Beta2Spec#certSecretRef
   */
  readonly certSecretRef?: HelmRepositoryV1Beta2SpecCertSecretRef;

  /**
   * Insecure allows connecting to a non-TLS HTTP container registry.
   * This field is only taken into account if the .spec.type field is set to 'oci'.
   *
   * @schema HelmRepositoryV1Beta2Spec#insecure
   */
  readonly insecure?: boolean;

  /**
   * Interval at which the HelmRepository URL is checked for updates.
   * This interval is approximate and may be subject to jitter to ensure
   * efficient use of resources.
   *
   * @schema HelmRepositoryV1Beta2Spec#interval
   */
  readonly interval?: string;

  /**
   * PassCredentials allows the credentials from the SecretRef to be passed
   * on to a host that does not match the host as defined in URL.
   * This may be required if the host of the advertised chart URLs in the
   * index differ from the defined URL.
   * Enabling this should be done with caution, as it can potentially result
   * in credentials getting stolen in a MITM-attack.
   *
   * @schema HelmRepositoryV1Beta2Spec#passCredentials
   */
  readonly passCredentials?: boolean;

  /**
   * Provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
   * This field is optional, and only taken into account if the .spec.type field is set to 'oci'.
   * When not specified, defaults to 'generic'.
   *
   * @schema HelmRepositoryV1Beta2Spec#provider
   */
  readonly provider?: HelmRepositoryV1Beta2SpecProvider;

  /**
   * SecretRef specifies the Secret containing authentication credentials
   * for the HelmRepository.
   * For HTTP/S basic auth the secret must contain 'username' and 'password'
   * fields.
   * Support for TLS auth using the 'certFile' and 'keyFile', and/or 'caFile'
   * keys is deprecated. Please use `.spec.certSecretRef` instead.
   *
   * @schema HelmRepositoryV1Beta2Spec#secretRef
   */
  readonly secretRef?: HelmRepositoryV1Beta2SpecSecretRef;

  /**
   * Suspend tells the controller to suspend the reconciliation of this
   * HelmRepository.
   *
   * @schema HelmRepositoryV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout is used for the index fetch operation for an HTTPS helm repository,
   * and for remote OCI Repository operations like pulling for an OCI helm
   * chart by the associated HelmChart.
   * Its default value is 60s.
   *
   * @schema HelmRepositoryV1Beta2Spec#timeout
   */
  readonly timeout?: string;

  /**
   * Type of the HelmRepository.
   * When this field is set to  "oci", the URL field value must be prefixed with "oci://".
   *
   * @schema HelmRepositoryV1Beta2Spec#type
   */
  readonly type?: HelmRepositoryV1Beta2SpecType;

  /**
   * URL of the Helm repository, a valid URL contains at least a protocol and
   * host.
   *
   * @schema HelmRepositoryV1Beta2Spec#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta2Spec(obj: HelmRepositoryV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_HelmRepositoryV1Beta2SpecAccessFrom(obj.accessFrom),
    'certSecretRef': toJson_HelmRepositoryV1Beta2SpecCertSecretRef(obj.certSecretRef),
    'insecure': obj.insecure,
    'interval': obj.interval,
    'passCredentials': obj.passCredentials,
    'provider': obj.provider,
    'secretRef': toJson_HelmRepositoryV1Beta2SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'type': obj.type,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom specifies an Access Control List for allowing cross-namespace
 * references to this object.
 * NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
 *
 * @schema HelmRepositoryV1Beta2SpecAccessFrom
 */
export interface HelmRepositoryV1Beta2SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema HelmRepositoryV1Beta2SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta2SpecAccessFrom(obj: HelmRepositoryV1Beta2SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef can be given the name of a Secret containing
 * either or both of
 *
 * - a PEM-encoded client certificate (`tls.crt`) and private
 * key (`tls.key`);
 * - a PEM-encoded CA certificate (`ca.crt`)
 *
 * and whichever are supplied, will be used for connecting to the
 * registry. The client cert and key are useful if you are
 * authenticating with a certificate; the CA cert is useful if
 * you are using a self-signed server certificate. The Secret must
 * be of type `Opaque` or `kubernetes.io/tls`.
 *
 * It takes precedence over the values specified in the Secret referred
 * to by `.spec.secretRef`.
 *
 * @schema HelmRepositoryV1Beta2SpecCertSecretRef
 */
export interface HelmRepositoryV1Beta2SpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema HelmRepositoryV1Beta2SpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2SpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta2SpecCertSecretRef(obj: HelmRepositoryV1Beta2SpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
 * This field is optional, and only taken into account if the .spec.type field is set to 'oci'.
 * When not specified, defaults to 'generic'.
 *
 * @schema HelmRepositoryV1Beta2SpecProvider
 */
export enum HelmRepositoryV1Beta2SpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** azure */
  AZURE = "azure",
  /** gcp */
  GCP = "gcp",
}

/**
 * SecretRef specifies the Secret containing authentication credentials
 * for the HelmRepository.
 * For HTTP/S basic auth the secret must contain 'username' and 'password'
 * fields.
 * Support for TLS auth using the 'certFile' and 'keyFile', and/or 'caFile'
 * keys is deprecated. Please use `.spec.certSecretRef` instead.
 *
 * @schema HelmRepositoryV1Beta2SpecSecretRef
 */
export interface HelmRepositoryV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema HelmRepositoryV1Beta2SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta2SpecSecretRef(obj: HelmRepositoryV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of the HelmRepository.
 * When this field is set to  "oci", the URL field value must be prefixed with "oci://".
 *
 * @schema HelmRepositoryV1Beta2SpecType
 */
export enum HelmRepositoryV1Beta2SpecType {
  /** default */
  DEFAULT = "default",
  /** oci */
  OCI = "oci",
}

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors
 */
export interface HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors(obj: HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * OCIRepository is the Schema for the ocirepositories API
 *
 * @schema OCIRepository
 */
export class OciRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OCIRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1',
    kind: 'OCIRepository',
  }

  /**
   * Renders a Kubernetes manifest for "OCIRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OciRepositoryProps = {}): any {
    return {
      ...OciRepository.GVK,
      ...toJson_OciRepositoryProps(props),
    };
  }

  /**
   * Defines a "OCIRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OciRepositoryProps = {}) {
    super(scope, id, {
      ...OciRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...OciRepository.GVK,
      ...toJson_OciRepositoryProps(resolved),
    };
  }
}

/**
 * OCIRepository is the Schema for the ocirepositories API
 *
 * @schema OCIRepository
 */
export interface OciRepositoryProps {
  /**
   * @schema OCIRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OCIRepositorySpec defines the desired state of OCIRepository
   *
   * @schema OCIRepository#spec
   */
  readonly spec?: OciRepositorySpec;

}

/**
 * Converts an object of type 'OciRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryProps(obj: OciRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OciRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OCIRepositorySpec defines the desired state of OCIRepository
 *
 * @schema OciRepositorySpec
 */
export interface OciRepositorySpec {
  /**
   * CertSecretRef can be given the name of a Secret containing
   * either or both of
   *
   * - a PEM-encoded client certificate (`tls.crt`) and private
   * key (`tls.key`);
   * - a PEM-encoded CA certificate (`ca.crt`)
   *
   * and whichever are supplied, will be used for connecting to the
   * registry. The client cert and key are useful if you are
   * authenticating with a certificate; the CA cert is useful if
   * you are using a self-signed server certificate. The Secret must
   * be of type `Opaque` or `kubernetes.io/tls`.
   *
   * @schema OciRepositorySpec#certSecretRef
   */
  readonly certSecretRef?: OciRepositorySpecCertSecretRef;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format
   * (which is the same as .gitignore). If not provided, a default will be used,
   * consult the documentation for your version to find out what those are.
   *
   * @schema OciRepositorySpec#ignore
   */
  readonly ignore?: string;

  /**
   * Insecure allows connecting to a non-TLS HTTP container registry.
   *
   * @schema OciRepositorySpec#insecure
   */
  readonly insecure?: boolean;

  /**
   * Interval at which the OCIRepository URL is checked for updates.
   * This interval is approximate and may be subject to jitter to ensure
   * efficient use of resources.
   *
   * @schema OciRepositorySpec#interval
   */
  readonly interval: string;

  /**
   * LayerSelector specifies which layer should be extracted from the OCI artifact.
   * When not specified, the first layer found in the artifact is selected.
   *
   * @schema OciRepositorySpec#layerSelector
   */
  readonly layerSelector?: OciRepositorySpecLayerSelector;

  /**
   * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
   * When not specified, defaults to 'generic'.
   *
   * @schema OciRepositorySpec#provider
   */
  readonly provider?: OciRepositorySpecProvider;

  /**
   * ProxySecretRef specifies the Secret containing the proxy configuration
   * to use while communicating with the container registry.
   *
   * @schema OciRepositorySpec#proxySecretRef
   */
  readonly proxySecretRef?: OciRepositorySpecProxySecretRef;

  /**
   * The OCI reference to pull and monitor for changes,
   * defaults to the latest tag.
   *
   * @schema OciRepositorySpec#ref
   */
  readonly ref?: OciRepositorySpecRef;

  /**
   * SecretRef contains the secret name containing the registry login
   * credentials to resolve image metadata.
   * The secret must be of type kubernetes.io/dockerconfigjson.
   *
   * @schema OciRepositorySpec#secretRef
   */
  readonly secretRef?: OciRepositorySpecSecretRef;

  /**
   * ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate
   * the image pull if the service account has attached pull secrets. For more information:
   * https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account
   *
   * @schema OciRepositorySpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema OciRepositorySpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout for remote OCI Repository operations like pulling, defaults to 60s.
   *
   * @schema OciRepositorySpec#timeout
   */
  readonly timeout?: string;

  /**
   * URL is a reference to an OCI artifact repository hosted
   * on a remote container registry.
   *
   * @schema OciRepositorySpec#url
   */
  readonly url: string;

  /**
   * Verify contains the secret name containing the trusted public keys
   * used to verify the signature and specifies which provider to use to check
   * whether OCI image is authentic.
   *
   * @schema OciRepositorySpec#verify
   */
  readonly verify?: OciRepositorySpecVerify;

}

/**
 * Converts an object of type 'OciRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositorySpec(obj: OciRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_OciRepositorySpecCertSecretRef(obj.certSecretRef),
    'ignore': obj.ignore,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'layerSelector': toJson_OciRepositorySpecLayerSelector(obj.layerSelector),
    'provider': obj.provider,
    'proxySecretRef': toJson_OciRepositorySpecProxySecretRef(obj.proxySecretRef),
    'ref': toJson_OciRepositorySpecRef(obj.ref),
    'secretRef': toJson_OciRepositorySpecSecretRef(obj.secretRef),
    'serviceAccountName': obj.serviceAccountName,
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
    'verify': toJson_OciRepositorySpecVerify(obj.verify),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef can be given the name of a Secret containing
 * either or both of
 *
 * - a PEM-encoded client certificate (`tls.crt`) and private
 * key (`tls.key`);
 * - a PEM-encoded CA certificate (`ca.crt`)
 *
 * and whichever are supplied, will be used for connecting to the
 * registry. The client cert and key are useful if you are
 * authenticating with a certificate; the CA cert is useful if
 * you are using a self-signed server certificate. The Secret must
 * be of type `Opaque` or `kubernetes.io/tls`.
 *
 * @schema OciRepositorySpecCertSecretRef
 */
export interface OciRepositorySpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositorySpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositorySpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositorySpecCertSecretRef(obj: OciRepositorySpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LayerSelector specifies which layer should be extracted from the OCI artifact.
 * When not specified, the first layer found in the artifact is selected.
 *
 * @schema OciRepositorySpecLayerSelector
 */
export interface OciRepositorySpecLayerSelector {
  /**
   * MediaType specifies the OCI media type of the layer
   * which should be extracted from the OCI Artifact. The
   * first layer matching this type is selected.
   *
   * @schema OciRepositorySpecLayerSelector#mediaType
   */
  readonly mediaType?: string;

  /**
   * Operation specifies how the selected layer should be processed.
   * By default, the layer compressed content is extracted to storage.
   * When the operation is set to 'copy', the layer compressed content
   * is persisted to storage as it is.
   *
   * @schema OciRepositorySpecLayerSelector#operation
   */
  readonly operation?: OciRepositorySpecLayerSelectorOperation;

}

/**
 * Converts an object of type 'OciRepositorySpecLayerSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositorySpecLayerSelector(obj: OciRepositorySpecLayerSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mediaType': obj.mediaType,
    'operation': obj.operation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
 * When not specified, defaults to 'generic'.
 *
 * @schema OciRepositorySpecProvider
 */
export enum OciRepositorySpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** azure */
  AZURE = "azure",
  /** gcp */
  GCP = "gcp",
}

/**
 * ProxySecretRef specifies the Secret containing the proxy configuration
 * to use while communicating with the container registry.
 *
 * @schema OciRepositorySpecProxySecretRef
 */
export interface OciRepositorySpecProxySecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositorySpecProxySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositorySpecProxySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositorySpecProxySecretRef(obj: OciRepositorySpecProxySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The OCI reference to pull and monitor for changes,
 * defaults to the latest tag.
 *
 * @schema OciRepositorySpecRef
 */
export interface OciRepositorySpecRef {
  /**
   * Digest is the image digest to pull, takes precedence over SemVer.
   * The value should be in the format 'sha256:<HASH>'.
   *
   * @schema OciRepositorySpecRef#digest
   */
  readonly digest?: string;

  /**
   * SemVer is the range of tags to pull selecting the latest within
   * the range, takes precedence over Tag.
   *
   * @schema OciRepositorySpecRef#semver
   */
  readonly semver?: string;

  /**
   * SemverFilter is a regex pattern to filter the tags within the SemVer range.
   *
   * @schema OciRepositorySpecRef#semverFilter
   */
  readonly semverFilter?: string;

  /**
   * Tag is the image tag to pull, defaults to latest.
   *
   * @schema OciRepositorySpecRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'OciRepositorySpecRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositorySpecRef(obj: OciRepositorySpecRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'digest': obj.digest,
    'semver': obj.semver,
    'semverFilter': obj.semverFilter,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains the secret name containing the registry login
 * credentials to resolve image metadata.
 * The secret must be of type kubernetes.io/dockerconfigjson.
 *
 * @schema OciRepositorySpecSecretRef
 */
export interface OciRepositorySpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositorySpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositorySpecSecretRef(obj: OciRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Verify contains the secret name containing the trusted public keys
 * used to verify the signature and specifies which provider to use to check
 * whether OCI image is authentic.
 *
 * @schema OciRepositorySpecVerify
 */
export interface OciRepositorySpecVerify {
  /**
   * MatchOIDCIdentity specifies the identity matching criteria to use
   * while verifying an OCI artifact which was signed using Cosign keyless
   * signing. The artifact's identity is deemed to be verified if any of the
   * specified matchers match against the identity.
   *
   * @schema OciRepositorySpecVerify#matchOIDCIdentity
   */
  readonly matchOidcIdentity?: OciRepositorySpecVerifyMatchOidcIdentity[];

  /**
   * Provider specifies the technology used to sign the OCI Artifact.
   *
   * @schema OciRepositorySpecVerify#provider
   */
  readonly provider: OciRepositorySpecVerifyProvider;

  /**
   * SecretRef specifies the Kubernetes Secret containing the
   * trusted public keys.
   *
   * @schema OciRepositorySpecVerify#secretRef
   */
  readonly secretRef?: OciRepositorySpecVerifySecretRef;

}

/**
 * Converts an object of type 'OciRepositorySpecVerify' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositorySpecVerify(obj: OciRepositorySpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchOIDCIdentity': obj.matchOidcIdentity?.map(y => toJson_OciRepositorySpecVerifyMatchOidcIdentity(y)),
    'provider': obj.provider,
    'secretRef': toJson_OciRepositorySpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operation specifies how the selected layer should be processed.
 * By default, the layer compressed content is extracted to storage.
 * When the operation is set to 'copy', the layer compressed content
 * is persisted to storage as it is.
 *
 * @schema OciRepositorySpecLayerSelectorOperation
 */
export enum OciRepositorySpecLayerSelectorOperation {
  /** extract */
  EXTRACT = "extract",
  /** copy */
  COPY = "copy",
}

/**
 * OIDCIdentityMatch specifies options for verifying the certificate identity,
 * i.e. the issuer and the subject of the certificate.
 *
 * @schema OciRepositorySpecVerifyMatchOidcIdentity
 */
export interface OciRepositorySpecVerifyMatchOidcIdentity {
  /**
   * Issuer specifies the regex pattern to match against to verify
   * the OIDC issuer in the Fulcio certificate. The pattern must be a
   * valid Go regular expression.
   *
   * @schema OciRepositorySpecVerifyMatchOidcIdentity#issuer
   */
  readonly issuer: string;

  /**
   * Subject specifies the regex pattern to match against to verify
   * the identity subject in the Fulcio certificate. The pattern must
   * be a valid Go regular expression.
   *
   * @schema OciRepositorySpecVerifyMatchOidcIdentity#subject
   */
  readonly subject: string;

}

/**
 * Converts an object of type 'OciRepositorySpecVerifyMatchOidcIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositorySpecVerifyMatchOidcIdentity(obj: OciRepositorySpecVerifyMatchOidcIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issuer': obj.issuer,
    'subject': obj.subject,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider specifies the technology used to sign the OCI Artifact.
 *
 * @schema OciRepositorySpecVerifyProvider
 */
export enum OciRepositorySpecVerifyProvider {
  /** cosign */
  COSIGN = "cosign",
  /** notation */
  NOTATION = "notation",
}

/**
 * SecretRef specifies the Kubernetes Secret containing the
 * trusted public keys.
 *
 * @schema OciRepositorySpecVerifySecretRef
 */
export interface OciRepositorySpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositorySpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositorySpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositorySpecVerifySecretRef(obj: OciRepositorySpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * OCIRepository is the Schema for the ocirepositories API
 *
 * @schema OCIRepositoryV1Beta2
 */
export class OciRepositoryV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OCIRepositoryV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta2',
    kind: 'OCIRepository',
  }

  /**
   * Renders a Kubernetes manifest for "OCIRepositoryV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OciRepositoryV1Beta2Props = {}): any {
    return {
      ...OciRepositoryV1Beta2.GVK,
      ...toJson_OciRepositoryV1Beta2Props(props),
    };
  }

  /**
   * Defines a "OCIRepositoryV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OciRepositoryV1Beta2Props = {}) {
    super(scope, id, {
      ...OciRepositoryV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...OciRepositoryV1Beta2.GVK,
      ...toJson_OciRepositoryV1Beta2Props(resolved),
    };
  }
}

/**
 * OCIRepository is the Schema for the ocirepositories API
 *
 * @schema OCIRepositoryV1Beta2
 */
export interface OciRepositoryV1Beta2Props {
  /**
   * @schema OCIRepositoryV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OCIRepositorySpec defines the desired state of OCIRepository
   *
   * @schema OCIRepositoryV1Beta2#spec
   */
  readonly spec?: OciRepositoryV1Beta2Spec;

}

/**
 * Converts an object of type 'OciRepositoryV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryV1Beta2Props(obj: OciRepositoryV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OciRepositoryV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OCIRepositorySpec defines the desired state of OCIRepository
 *
 * @schema OciRepositoryV1Beta2Spec
 */
export interface OciRepositoryV1Beta2Spec {
  /**
   * CertSecretRef can be given the name of a Secret containing
   * either or both of
   *
   * - a PEM-encoded client certificate (`tls.crt`) and private
   * key (`tls.key`);
   * - a PEM-encoded CA certificate (`ca.crt`)
   *
   * and whichever are supplied, will be used for connecting to the
   * registry. The client cert and key are useful if you are
   * authenticating with a certificate; the CA cert is useful if
   * you are using a self-signed server certificate. The Secret must
   * be of type `Opaque` or `kubernetes.io/tls`.
   *
   * Note: Support for the `caFile`, `certFile` and `keyFile` keys have
   * been deprecated.
   *
   * @schema OciRepositoryV1Beta2Spec#certSecretRef
   */
  readonly certSecretRef?: OciRepositoryV1Beta2SpecCertSecretRef;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format
   * (which is the same as .gitignore). If not provided, a default will be used,
   * consult the documentation for your version to find out what those are.
   *
   * @schema OciRepositoryV1Beta2Spec#ignore
   */
  readonly ignore?: string;

  /**
   * Insecure allows connecting to a non-TLS HTTP container registry.
   *
   * @schema OciRepositoryV1Beta2Spec#insecure
   */
  readonly insecure?: boolean;

  /**
   * Interval at which the OCIRepository URL is checked for updates.
   * This interval is approximate and may be subject to jitter to ensure
   * efficient use of resources.
   *
   * @schema OciRepositoryV1Beta2Spec#interval
   */
  readonly interval: string;

  /**
   * LayerSelector specifies which layer should be extracted from the OCI artifact.
   * When not specified, the first layer found in the artifact is selected.
   *
   * @schema OciRepositoryV1Beta2Spec#layerSelector
   */
  readonly layerSelector?: OciRepositoryV1Beta2SpecLayerSelector;

  /**
   * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
   * When not specified, defaults to 'generic'.
   *
   * @schema OciRepositoryV1Beta2Spec#provider
   */
  readonly provider?: OciRepositoryV1Beta2SpecProvider;

  /**
   * ProxySecretRef specifies the Secret containing the proxy configuration
   * to use while communicating with the container registry.
   *
   * @schema OciRepositoryV1Beta2Spec#proxySecretRef
   */
  readonly proxySecretRef?: OciRepositoryV1Beta2SpecProxySecretRef;

  /**
   * The OCI reference to pull and monitor for changes,
   * defaults to the latest tag.
   *
   * @schema OciRepositoryV1Beta2Spec#ref
   */
  readonly ref?: OciRepositoryV1Beta2SpecRef;

  /**
   * SecretRef contains the secret name containing the registry login
   * credentials to resolve image metadata.
   * The secret must be of type kubernetes.io/dockerconfigjson.
   *
   * @schema OciRepositoryV1Beta2Spec#secretRef
   */
  readonly secretRef?: OciRepositoryV1Beta2SpecSecretRef;

  /**
   * ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate
   * the image pull if the service account has attached pull secrets. For more information:
   * https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account
   *
   * @schema OciRepositoryV1Beta2Spec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema OciRepositoryV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout for remote OCI Repository operations like pulling, defaults to 60s.
   *
   * @schema OciRepositoryV1Beta2Spec#timeout
   */
  readonly timeout?: string;

  /**
   * URL is a reference to an OCI artifact repository hosted
   * on a remote container registry.
   *
   * @schema OciRepositoryV1Beta2Spec#url
   */
  readonly url: string;

  /**
   * Verify contains the secret name containing the trusted public keys
   * used to verify the signature and specifies which provider to use to check
   * whether OCI image is authentic.
   *
   * @schema OciRepositoryV1Beta2Spec#verify
   */
  readonly verify?: OciRepositoryV1Beta2SpecVerify;

}

/**
 * Converts an object of type 'OciRepositoryV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryV1Beta2Spec(obj: OciRepositoryV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_OciRepositoryV1Beta2SpecCertSecretRef(obj.certSecretRef),
    'ignore': obj.ignore,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'layerSelector': toJson_OciRepositoryV1Beta2SpecLayerSelector(obj.layerSelector),
    'provider': obj.provider,
    'proxySecretRef': toJson_OciRepositoryV1Beta2SpecProxySecretRef(obj.proxySecretRef),
    'ref': toJson_OciRepositoryV1Beta2SpecRef(obj.ref),
    'secretRef': toJson_OciRepositoryV1Beta2SpecSecretRef(obj.secretRef),
    'serviceAccountName': obj.serviceAccountName,
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
    'verify': toJson_OciRepositoryV1Beta2SpecVerify(obj.verify),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef can be given the name of a Secret containing
 * either or both of
 *
 * - a PEM-encoded client certificate (`tls.crt`) and private
 * key (`tls.key`);
 * - a PEM-encoded CA certificate (`ca.crt`)
 *
 * and whichever are supplied, will be used for connecting to the
 * registry. The client cert and key are useful if you are
 * authenticating with a certificate; the CA cert is useful if
 * you are using a self-signed server certificate. The Secret must
 * be of type `Opaque` or `kubernetes.io/tls`.
 *
 * Note: Support for the `caFile`, `certFile` and `keyFile` keys have
 * been deprecated.
 *
 * @schema OciRepositoryV1Beta2SpecCertSecretRef
 */
export interface OciRepositoryV1Beta2SpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositoryV1Beta2SpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositoryV1Beta2SpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryV1Beta2SpecCertSecretRef(obj: OciRepositoryV1Beta2SpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LayerSelector specifies which layer should be extracted from the OCI artifact.
 * When not specified, the first layer found in the artifact is selected.
 *
 * @schema OciRepositoryV1Beta2SpecLayerSelector
 */
export interface OciRepositoryV1Beta2SpecLayerSelector {
  /**
   * MediaType specifies the OCI media type of the layer
   * which should be extracted from the OCI Artifact. The
   * first layer matching this type is selected.
   *
   * @schema OciRepositoryV1Beta2SpecLayerSelector#mediaType
   */
  readonly mediaType?: string;

  /**
   * Operation specifies how the selected layer should be processed.
   * By default, the layer compressed content is extracted to storage.
   * When the operation is set to 'copy', the layer compressed content
   * is persisted to storage as it is.
   *
   * @schema OciRepositoryV1Beta2SpecLayerSelector#operation
   */
  readonly operation?: OciRepositoryV1Beta2SpecLayerSelectorOperation;

}

/**
 * Converts an object of type 'OciRepositoryV1Beta2SpecLayerSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryV1Beta2SpecLayerSelector(obj: OciRepositoryV1Beta2SpecLayerSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mediaType': obj.mediaType,
    'operation': obj.operation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
 * When not specified, defaults to 'generic'.
 *
 * @schema OciRepositoryV1Beta2SpecProvider
 */
export enum OciRepositoryV1Beta2SpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** azure */
  AZURE = "azure",
  /** gcp */
  GCP = "gcp",
}

/**
 * ProxySecretRef specifies the Secret containing the proxy configuration
 * to use while communicating with the container registry.
 *
 * @schema OciRepositoryV1Beta2SpecProxySecretRef
 */
export interface OciRepositoryV1Beta2SpecProxySecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositoryV1Beta2SpecProxySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositoryV1Beta2SpecProxySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryV1Beta2SpecProxySecretRef(obj: OciRepositoryV1Beta2SpecProxySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The OCI reference to pull and monitor for changes,
 * defaults to the latest tag.
 *
 * @schema OciRepositoryV1Beta2SpecRef
 */
export interface OciRepositoryV1Beta2SpecRef {
  /**
   * Digest is the image digest to pull, takes precedence over SemVer.
   * The value should be in the format 'sha256:<HASH>'.
   *
   * @schema OciRepositoryV1Beta2SpecRef#digest
   */
  readonly digest?: string;

  /**
   * SemVer is the range of tags to pull selecting the latest within
   * the range, takes precedence over Tag.
   *
   * @schema OciRepositoryV1Beta2SpecRef#semver
   */
  readonly semver?: string;

  /**
   * SemverFilter is a regex pattern to filter the tags within the SemVer range.
   *
   * @schema OciRepositoryV1Beta2SpecRef#semverFilter
   */
  readonly semverFilter?: string;

  /**
   * Tag is the image tag to pull, defaults to latest.
   *
   * @schema OciRepositoryV1Beta2SpecRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'OciRepositoryV1Beta2SpecRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryV1Beta2SpecRef(obj: OciRepositoryV1Beta2SpecRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'digest': obj.digest,
    'semver': obj.semver,
    'semverFilter': obj.semverFilter,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains the secret name containing the registry login
 * credentials to resolve image metadata.
 * The secret must be of type kubernetes.io/dockerconfigjson.
 *
 * @schema OciRepositoryV1Beta2SpecSecretRef
 */
export interface OciRepositoryV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositoryV1Beta2SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositoryV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryV1Beta2SpecSecretRef(obj: OciRepositoryV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Verify contains the secret name containing the trusted public keys
 * used to verify the signature and specifies which provider to use to check
 * whether OCI image is authentic.
 *
 * @schema OciRepositoryV1Beta2SpecVerify
 */
export interface OciRepositoryV1Beta2SpecVerify {
  /**
   * MatchOIDCIdentity specifies the identity matching criteria to use
   * while verifying an OCI artifact which was signed using Cosign keyless
   * signing. The artifact's identity is deemed to be verified if any of the
   * specified matchers match against the identity.
   *
   * @schema OciRepositoryV1Beta2SpecVerify#matchOIDCIdentity
   */
  readonly matchOidcIdentity?: OciRepositoryV1Beta2SpecVerifyMatchOidcIdentity[];

  /**
   * Provider specifies the technology used to sign the OCI Artifact.
   *
   * @schema OciRepositoryV1Beta2SpecVerify#provider
   */
  readonly provider: OciRepositoryV1Beta2SpecVerifyProvider;

  /**
   * SecretRef specifies the Kubernetes Secret containing the
   * trusted public keys.
   *
   * @schema OciRepositoryV1Beta2SpecVerify#secretRef
   */
  readonly secretRef?: OciRepositoryV1Beta2SpecVerifySecretRef;

}

/**
 * Converts an object of type 'OciRepositoryV1Beta2SpecVerify' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryV1Beta2SpecVerify(obj: OciRepositoryV1Beta2SpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchOIDCIdentity': obj.matchOidcIdentity?.map(y => toJson_OciRepositoryV1Beta2SpecVerifyMatchOidcIdentity(y)),
    'provider': obj.provider,
    'secretRef': toJson_OciRepositoryV1Beta2SpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operation specifies how the selected layer should be processed.
 * By default, the layer compressed content is extracted to storage.
 * When the operation is set to 'copy', the layer compressed content
 * is persisted to storage as it is.
 *
 * @schema OciRepositoryV1Beta2SpecLayerSelectorOperation
 */
export enum OciRepositoryV1Beta2SpecLayerSelectorOperation {
  /** extract */
  EXTRACT = "extract",
  /** copy */
  COPY = "copy",
}

/**
 * OIDCIdentityMatch specifies options for verifying the certificate identity,
 * i.e. the issuer and the subject of the certificate.
 *
 * @schema OciRepositoryV1Beta2SpecVerifyMatchOidcIdentity
 */
export interface OciRepositoryV1Beta2SpecVerifyMatchOidcIdentity {
  /**
   * Issuer specifies the regex pattern to match against to verify
   * the OIDC issuer in the Fulcio certificate. The pattern must be a
   * valid Go regular expression.
   *
   * @schema OciRepositoryV1Beta2SpecVerifyMatchOidcIdentity#issuer
   */
  readonly issuer: string;

  /**
   * Subject specifies the regex pattern to match against to verify
   * the identity subject in the Fulcio certificate. The pattern must
   * be a valid Go regular expression.
   *
   * @schema OciRepositoryV1Beta2SpecVerifyMatchOidcIdentity#subject
   */
  readonly subject: string;

}

/**
 * Converts an object of type 'OciRepositoryV1Beta2SpecVerifyMatchOidcIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryV1Beta2SpecVerifyMatchOidcIdentity(obj: OciRepositoryV1Beta2SpecVerifyMatchOidcIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issuer': obj.issuer,
    'subject': obj.subject,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider specifies the technology used to sign the OCI Artifact.
 *
 * @schema OciRepositoryV1Beta2SpecVerifyProvider
 */
export enum OciRepositoryV1Beta2SpecVerifyProvider {
  /** cosign */
  COSIGN = "cosign",
  /** notation */
  NOTATION = "notation",
}

/**
 * SecretRef specifies the Kubernetes Secret containing the
 * trusted public keys.
 *
 * @schema OciRepositoryV1Beta2SpecVerifySecretRef
 */
export interface OciRepositoryV1Beta2SpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositoryV1Beta2SpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositoryV1Beta2SpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OciRepositoryV1Beta2SpecVerifySecretRef(obj: OciRepositoryV1Beta2SpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

